{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stories \u00b6 The business transaction DSL stories is a business transaction DSL. It provides a simple way to define a complex business transaction that includes processing over many steps and by many different objects. It makes error handling a primary concern by taking a \u201c Railway Oriented Programming \u201d approach to capturing and returning errors from any step in the transaction. stories is based on the following ideas: A business transaction is a series of operations where any can fail and stop the processing. A business transaction can describe its steps on an abstract level without being coupled to any details about how individual operations work. A business transaction doesn\u2019t have any state. Each operation shouldn\u2019t accumulate state, instead it should receive an input and return an output without causing any side-effects. The only interface of an operation is ctx . Each operation provides a meaningful piece of functionality and can be reused. Errors in any operation should be easily caught and handled as part of the normal application flow. Example \u00b6 stories provide a simple way to define a complex business scenario that include many processing steps. sync >>> from stories import story , arguments , Success , Failure , Result >>> from app.repositories import load_category , load_profile , create_subscription >>> class Subscribe : ... ... @story ... @arguments ( 'category_id' , 'profile_id' ) ... def buy ( I ): ... ... I . find_category ... I . find_profile ... I . check_balance ... I . persist_subscription ... I . show_subscription ... ... def find_category ( self , ctx ): ... ... ctx . category = load_category ( ctx . category_id ) ... return Success () ... ... def find_profile ( self , ctx ): ... ... ctx . profile = load_profile ( ctx . profile_id ) ... return Success () ... ... def check_balance ( self , ctx ): ... ... if ctx . category . cost < ctx . profile . balance : ... return Success () ... else : ... return Failure () ... ... def persist_subscription ( self , ctx ): ... ... ctx . subscription = create_subscription ( category = ctx . category , profile = ctx . profile ) ... return Success () ... ... def show_subscription ( self , ctx ): ... ... return Result ( ctx . subscription ) >>> Subscribe () . buy ( category_id = 1 , profile_id = 1 ) Subscription(primary_key=10) async >>> import asyncio >>> from stories import story , arguments , Success , Failure , Result >>> from aioapp.repositories import load_category , load_profile , create_subscription >>> class Subscribe : ... ... @story ... @arguments ( 'category_id' , 'profile_id' ) ... def buy ( I ): ... ... I . find_category ... I . find_profile ... I . check_balance ... I . persist_subscription ... I . show_subscription ... ... async def find_category ( self , ctx ): ... ... ctx . category = await load_category ( ctx . category_id ) ... return Success () ... ... async def find_profile ( self , ctx ): ... ... ctx . profile = await load_profile ( ctx . profile_id ) ... return Success () ... ... async def check_balance ( self , ctx ): ... ... if ctx . category . cost < ctx . profile . balance : ... return Success () ... else : ... return Failure () ... ... async def persist_subscription ( self , ctx ): ... ... ctx . subscription = await create_subscription ( category = ctx . category , profile = ctx . profile ) ... return Success () ... ... async def show_subscription ( self , ctx ): ... ... return Result ( ctx . subscription ) >>> asyncio . run ( Subscribe () . buy ( category_id = 1 , profile_id = 1 )) Subscription(primary_key=9) This code style allow you clearly separate actual business scenario from implementation details. Note stories library was heavily inspired by dry-transaction ruby gem. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Home"},{"location":"#stories","text":"The business transaction DSL stories is a business transaction DSL. It provides a simple way to define a complex business transaction that includes processing over many steps and by many different objects. It makes error handling a primary concern by taking a \u201c Railway Oriented Programming \u201d approach to capturing and returning errors from any step in the transaction. stories is based on the following ideas: A business transaction is a series of operations where any can fail and stop the processing. A business transaction can describe its steps on an abstract level without being coupled to any details about how individual operations work. A business transaction doesn\u2019t have any state. Each operation shouldn\u2019t accumulate state, instead it should receive an input and return an output without causing any side-effects. The only interface of an operation is ctx . Each operation provides a meaningful piece of functionality and can be reused. Errors in any operation should be easily caught and handled as part of the normal application flow.","title":"Stories"},{"location":"#example","text":"stories provide a simple way to define a complex business scenario that include many processing steps. sync >>> from stories import story , arguments , Success , Failure , Result >>> from app.repositories import load_category , load_profile , create_subscription >>> class Subscribe : ... ... @story ... @arguments ( 'category_id' , 'profile_id' ) ... def buy ( I ): ... ... I . find_category ... I . find_profile ... I . check_balance ... I . persist_subscription ... I . show_subscription ... ... def find_category ( self , ctx ): ... ... ctx . category = load_category ( ctx . category_id ) ... return Success () ... ... def find_profile ( self , ctx ): ... ... ctx . profile = load_profile ( ctx . profile_id ) ... return Success () ... ... def check_balance ( self , ctx ): ... ... if ctx . category . cost < ctx . profile . balance : ... return Success () ... else : ... return Failure () ... ... def persist_subscription ( self , ctx ): ... ... ctx . subscription = create_subscription ( category = ctx . category , profile = ctx . profile ) ... return Success () ... ... def show_subscription ( self , ctx ): ... ... return Result ( ctx . subscription ) >>> Subscribe () . buy ( category_id = 1 , profile_id = 1 ) Subscription(primary_key=10) async >>> import asyncio >>> from stories import story , arguments , Success , Failure , Result >>> from aioapp.repositories import load_category , load_profile , create_subscription >>> class Subscribe : ... ... @story ... @arguments ( 'category_id' , 'profile_id' ) ... def buy ( I ): ... ... I . find_category ... I . find_profile ... I . check_balance ... I . persist_subscription ... I . show_subscription ... ... async def find_category ( self , ctx ): ... ... ctx . category = await load_category ( ctx . category_id ) ... return Success () ... ... async def find_profile ( self , ctx ): ... ... ctx . profile = await load_profile ( ctx . profile_id ) ... return Success () ... ... async def check_balance ( self , ctx ): ... ... if ctx . category . cost < ctx . profile . balance : ... return Success () ... else : ... return Failure () ... ... async def persist_subscription ( self , ctx ): ... ... ctx . subscription = await create_subscription ( category = ctx . category , profile = ctx . profile ) ... return Success () ... ... async def show_subscription ( self , ctx ): ... ... return Result ( ctx . subscription ) >>> asyncio . run ( Subscribe () . buy ( category_id = 1 , profile_id = 1 )) Subscription(primary_key=9) This code style allow you clearly separate actual business scenario from implementation details. Note stories library was heavily inspired by dry-transaction ruby gem. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Example"},{"location":"changelog/","text":"1.0.0 (2020-05-22) \u00b6 Features \u00b6 deprecate substories defined within the class ( c5d7930 ), closes #388 BREAKING CHANGES \u00b6 Substories defined in the same class do not deserve special treatment. From now they require to have different context contracts and failure protocols. They will be interpreted the same way as if they were defined in the other class. Shortcuts module have been removed. 0.15.0 (2020-04-16) \u00b6 Features \u00b6 support Django 4.0 ( f02a334 ) 0.14.0 (2020-03-21) \u00b6 Features \u00b6 support marshmallow v3 as a context contract definition ( a87c0c4 ) 0.13.0 (2020-03-14) \u00b6 Features \u00b6 use assignment expression instead of Success keyword arguments ( 9756571 ) 0.12.0 (2020-03-06) \u00b6 Features \u00b6 support coroutine functions as story step definitions ( 55cbfda ) 0.11.2 (2020-03-02) \u00b6 Bug Fixes \u00b6 hide context private attributes in closure ( f8144aa ) hide failure and success summary private attributes in closure ( eae4e95 ) hide FailureError private attributes in closure ( 1fafcc1 ) hide story private attributes in closure ( 9e79e14 ) 0.11.1 (2020-02-28) \u00b6 Bug Fixes \u00b6 deny to define stories without steps ( 5067546 ) 0.11.0 (2020-02-14) \u00b6 Features \u00b6 Add context contract to the story. Success keyword arguments can be validated by contract definition in the story. Raise MutationError when some story method tries to set or delete context attribute directly. Only keyword arguments are allowed to call and run the story. Raise StoryDefinitionError when arguments decorator is used incorrectly. migrate to pydantic v1.x ( 9049eae ) 0.10.2 (2020-02-11) \u00b6 Bug Fixes \u00b6 prevent generated changelog from style guide violation ( 7d4047d ) 0.10.1 (2019-05-31) \u00b6 Fix pytest reporter to work with fixture functions and pytest-bdd plugin properly. 0.10 (2019-02-27) \u00b6 Add failure protocol of the story. Failure argument should match protocol definition in the story. Replace multiple argument decorators with single arguments . Raise ContextContractError when keyword argument given to Success already exists in the context. Raise ContextContractError when the story can not find necessary arguments in the context. Make context an immutable object. Python 3.7 support. 0.9 (2018-11-28) \u00b6 Enforce I noun with non callable attributes in the story definition. Context is passed as an argument into story step methods. Pass real class instances into step method. Show story execution path in the Context representation. Add Sentry, Py.test and Django Debug Toolbar plugins with Context reporter built in. Raise an exception on Failure when the story was called directly. Support iterable protocol in the Context class. Add Failure reason. Fix Skip result behavior in deeper sub-story hierarchy. 0.8 (2018-05-12) \u00b6 Add dir() and repr() support to the context class. Failed result holds a link to the context. 0.7 (2018-05-06) \u00b6 Add run interface to the story. 0.6 (2018-04-19) \u00b6 Representation methods for story, context and point result classes. Python 2 support. 0.5 (2018-04-07) \u00b6 Do not execute nested stories of the skipped story. 0.4 (2018-04-07) \u00b6 Package was rewritten with linearization algorithm. Skip result was added to finish nested stories without finish the caller. 0.0.3 (2018-04-06) \u00b6 Nested stories support. 0.0.2 (2018-04-03) \u00b6 Fix class and instance attribute access. Validate return values. Make context append only. 0.0.1 (2018-04-02) \u00b6 Initial release. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Changelog"},{"location":"changelog/#100-2020-05-22","text":"","title":"1.0.0 (2020-05-22)"},{"location":"changelog/#features","text":"deprecate substories defined within the class ( c5d7930 ), closes #388","title":"Features"},{"location":"changelog/#breaking-changes","text":"Substories defined in the same class do not deserve special treatment. From now they require to have different context contracts and failure protocols. They will be interpreted the same way as if they were defined in the other class. Shortcuts module have been removed.","title":"BREAKING CHANGES"},{"location":"changelog/#0150-2020-04-16","text":"","title":"0.15.0 (2020-04-16)"},{"location":"changelog/#features_1","text":"support Django 4.0 ( f02a334 )","title":"Features"},{"location":"changelog/#0140-2020-03-21","text":"","title":"0.14.0 (2020-03-21)"},{"location":"changelog/#features_2","text":"support marshmallow v3 as a context contract definition ( a87c0c4 )","title":"Features"},{"location":"changelog/#0130-2020-03-14","text":"","title":"0.13.0 (2020-03-14)"},{"location":"changelog/#features_3","text":"use assignment expression instead of Success keyword arguments ( 9756571 )","title":"Features"},{"location":"changelog/#0120-2020-03-06","text":"","title":"0.12.0 (2020-03-06)"},{"location":"changelog/#features_4","text":"support coroutine functions as story step definitions ( 55cbfda )","title":"Features"},{"location":"changelog/#0112-2020-03-02","text":"","title":"0.11.2 (2020-03-02)"},{"location":"changelog/#bug-fixes","text":"hide context private attributes in closure ( f8144aa ) hide failure and success summary private attributes in closure ( eae4e95 ) hide FailureError private attributes in closure ( 1fafcc1 ) hide story private attributes in closure ( 9e79e14 )","title":"Bug Fixes"},{"location":"changelog/#0111-2020-02-28","text":"","title":"0.11.1 (2020-02-28)"},{"location":"changelog/#bug-fixes_1","text":"deny to define stories without steps ( 5067546 )","title":"Bug Fixes"},{"location":"changelog/#0110-2020-02-14","text":"","title":"0.11.0 (2020-02-14)"},{"location":"changelog/#features_5","text":"Add context contract to the story. Success keyword arguments can be validated by contract definition in the story. Raise MutationError when some story method tries to set or delete context attribute directly. Only keyword arguments are allowed to call and run the story. Raise StoryDefinitionError when arguments decorator is used incorrectly. migrate to pydantic v1.x ( 9049eae )","title":"Features"},{"location":"changelog/#0102-2020-02-11","text":"","title":"0.10.2 (2020-02-11)"},{"location":"changelog/#bug-fixes_2","text":"prevent generated changelog from style guide violation ( 7d4047d )","title":"Bug Fixes"},{"location":"changelog/#0101-2019-05-31","text":"Fix pytest reporter to work with fixture functions and pytest-bdd plugin properly.","title":"0.10.1 (2019-05-31)"},{"location":"changelog/#010-2019-02-27","text":"Add failure protocol of the story. Failure argument should match protocol definition in the story. Replace multiple argument decorators with single arguments . Raise ContextContractError when keyword argument given to Success already exists in the context. Raise ContextContractError when the story can not find necessary arguments in the context. Make context an immutable object. Python 3.7 support.","title":"0.10 (2019-02-27)"},{"location":"changelog/#09-2018-11-28","text":"Enforce I noun with non callable attributes in the story definition. Context is passed as an argument into story step methods. Pass real class instances into step method. Show story execution path in the Context representation. Add Sentry, Py.test and Django Debug Toolbar plugins with Context reporter built in. Raise an exception on Failure when the story was called directly. Support iterable protocol in the Context class. Add Failure reason. Fix Skip result behavior in deeper sub-story hierarchy.","title":"0.9 (2018-11-28)"},{"location":"changelog/#08-2018-05-12","text":"Add dir() and repr() support to the context class. Failed result holds a link to the context.","title":"0.8 (2018-05-12)"},{"location":"changelog/#07-2018-05-06","text":"Add run interface to the story.","title":"0.7 (2018-05-06)"},{"location":"changelog/#06-2018-04-19","text":"Representation methods for story, context and point result classes. Python 2 support.","title":"0.6 (2018-04-19)"},{"location":"changelog/#05-2018-04-07","text":"Do not execute nested stories of the skipped story.","title":"0.5 (2018-04-07)"},{"location":"changelog/#04-2018-04-07","text":"Package was rewritten with linearization algorithm. Skip result was added to finish nested stories without finish the caller.","title":"0.4 (2018-04-07)"},{"location":"changelog/#003-2018-04-06","text":"Nested stories support.","title":"0.0.3 (2018-04-06)"},{"location":"changelog/#002-2018-04-03","text":"Fix class and instance attribute access. Validate return values. Make context append only.","title":"0.0.2 (2018-04-03)"},{"location":"changelog/#001-2018-04-02","text":"Initial release. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"0.0.1 (2018-04-02)"},{"location":"composition/","text":"Composition \u00b6 Sometimes you want to split your business logic into several parts inside a single story. Obviously, you want to do so to be able to reuse this parts in different stories. Or maybe your goal is grouping several steps into a sub-story for readability. There are several ways to do it. Note Failure protocol of the story composition is composition itself . It will use all reasons for all protocols of all stories used in the composition. Instance attributes \u00b6 We prefer to define our business logic in separate components with loose coupling. The final thing will be built later using composition. We use a well-known technique called Constructor dependency injection for it. The key point here: you can add story steps directly to the instance with attribute assignment. No matter where these steps come from, constructor or not. >>> from stories import story , arguments , Success , Failure >>> from app.services import MethodDefinitions >>> class Subscription ( MethodDefinitions ): ... ... @story ... @arguments ( \"category_id\" , \"price_id\" , \"profile_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_promo_code ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification ... I . show_category ... ... def __init__ ( self , find_promo_code ): ... ... self . find_promo_code = find_promo_code >>> class PromoCode ( MethodDefinitions ): ... ... @story ... @arguments ( \"category\" , \"price\" ) ... def find ( I ): ... ... I . find_token ... I . check_expiration ... I . calculate_discount At this moment, story definition does not know what find_promo_code step should be. >>> Subscription . buy Subscription.buy find_category find_price find_promo_code find_profile check_balance persist_payment persist_subscription send_subscription_notification show_category And when we create an instance of the class we will specify this explicitly. Representation of the instance attribute will show us the complete story. >>> Subscription ( PromoCode () . find ) . buy Subscription.buy find_category find_price find_promo_code (PromoCode.find) find_token check_expiration calculate_discount find_profile check_balance persist_payment persist_subscription send_subscription_notification show_category Delegate implementation \u00b6 We go even further in this approach. We compose not only stories, but the actual things we call in our steps come from outside. We never call methods of the Django model or requests package directly! We use simple rules to write our steps. The only thing you can access inside story step is an instance method. The return value of this call goes to the context with Success marker. Decisions are made by comparison context variables to each other or using methods of the context variable in the next story step. Here are some examples: sync >>> class Subscription : ... ... @story ... @arguments ( \"profile_id\" , \"price_id\" ) ... def buy ( I ): ... ... I . find_profile ... I . find_price ... I . check_balance ... ... def find_profile ( self , ctx ): ... ... ctx . profile = self . load_profile ( ctx . profile_id ) ... return Success () ... ... def find_price ( self , ctx ): ... ... ctx . price = self . load_price ( ctx . price_id ) ... return Success () ... ... def check_balance ( self , ctx ): ... ... if ctx . profile . has_enough_balance ( ctx . price ): ... return Success () ... else : ... return Failure () ... ... def __init__ ( self , load_profile , load_price ): ... ... self . load_profile = load_profile ... self . load_price = load_price >>> from app.db import ProfileTable , PriceTable >>> def load_profile ( profile_id ): ... return ProfileTable . where ( pk = profile_id ) . select () >>> def load_price ( price_id ): ... return PriceTable . where ( pk = price_id ) . select () >>> Subscription ( load_profile , load_price ) . buy ( profile_id = 1 , price_id = 7 ) async >>> class Subscription : ... ... @story ... @arguments ( \"profile_id\" , \"price_id\" ) ... def buy ( I ): ... ... I . find_profile ... I . find_price ... I . check_balance ... ... async def find_profile ( self , ctx ): ... ... ctx . profile = await self . load_profile ( ctx . profile_id ) ... return Success () ... ... async def find_price ( self , ctx ): ... ... ctx . price = await self . load_price ( ctx . price_id ) ... return Success () ... ... async def check_balance ( self , ctx ): ... ... if ctx . profile . has_enough_balance ( ctx . price ): ... return Success () ... else : ... return Failure () ... ... def __init__ ( self , load_profile , load_price ): ... ... self . load_profile = load_profile ... self . load_price = load_price >>> import asyncio >>> from aioapp.db import ProfileTable , PriceTable >>> async def load_profile ( profile_id ): ... return await ProfileTable . where ( pk = profile_id ) . select () >>> async def load_price ( price_id ): ... return await PriceTable . where ( pk = price_id ) . select () >>> asyncio . run ( Subscription ( load_profile , load_price ) . buy ( profile_id = 1 , price_id = 7 )) This way you decouple your business logic from relation mapper models or networking library! There is no more vendor lock on a certain framework or database! Welcome to the good architecture utopia. You can group delegates into a single object to avoid complex constructors and names duplication. sync >>> def find_price ( self , ctx ): ... ctx . price = self . impl . find_price ( ctx . price_id ) ... return Success () >>> def __init__ ( self , impl ): ... self . impl = impl async >>> async def find_price ( self , ctx ): ... ctx . price = await self . impl . find_price ( ctx . price_id ) ... return Success () >>> def __init__ ( self , impl ): ... self . impl = impl If you follow our mantra \"decouple everything\", you definitely should check the following libraries: dependencies attrs dataclasses \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Composition"},{"location":"composition/#composition","text":"Sometimes you want to split your business logic into several parts inside a single story. Obviously, you want to do so to be able to reuse this parts in different stories. Or maybe your goal is grouping several steps into a sub-story for readability. There are several ways to do it. Note Failure protocol of the story composition is composition itself . It will use all reasons for all protocols of all stories used in the composition.","title":"Composition"},{"location":"composition/#instance-attributes","text":"We prefer to define our business logic in separate components with loose coupling. The final thing will be built later using composition. We use a well-known technique called Constructor dependency injection for it. The key point here: you can add story steps directly to the instance with attribute assignment. No matter where these steps come from, constructor or not. >>> from stories import story , arguments , Success , Failure >>> from app.services import MethodDefinitions >>> class Subscription ( MethodDefinitions ): ... ... @story ... @arguments ( \"category_id\" , \"price_id\" , \"profile_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_promo_code ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification ... I . show_category ... ... def __init__ ( self , find_promo_code ): ... ... self . find_promo_code = find_promo_code >>> class PromoCode ( MethodDefinitions ): ... ... @story ... @arguments ( \"category\" , \"price\" ) ... def find ( I ): ... ... I . find_token ... I . check_expiration ... I . calculate_discount At this moment, story definition does not know what find_promo_code step should be. >>> Subscription . buy Subscription.buy find_category find_price find_promo_code find_profile check_balance persist_payment persist_subscription send_subscription_notification show_category And when we create an instance of the class we will specify this explicitly. Representation of the instance attribute will show us the complete story. >>> Subscription ( PromoCode () . find ) . buy Subscription.buy find_category find_price find_promo_code (PromoCode.find) find_token check_expiration calculate_discount find_profile check_balance persist_payment persist_subscription send_subscription_notification show_category","title":"Instance attributes"},{"location":"composition/#delegate-implementation","text":"We go even further in this approach. We compose not only stories, but the actual things we call in our steps come from outside. We never call methods of the Django model or requests package directly! We use simple rules to write our steps. The only thing you can access inside story step is an instance method. The return value of this call goes to the context with Success marker. Decisions are made by comparison context variables to each other or using methods of the context variable in the next story step. Here are some examples: sync >>> class Subscription : ... ... @story ... @arguments ( \"profile_id\" , \"price_id\" ) ... def buy ( I ): ... ... I . find_profile ... I . find_price ... I . check_balance ... ... def find_profile ( self , ctx ): ... ... ctx . profile = self . load_profile ( ctx . profile_id ) ... return Success () ... ... def find_price ( self , ctx ): ... ... ctx . price = self . load_price ( ctx . price_id ) ... return Success () ... ... def check_balance ( self , ctx ): ... ... if ctx . profile . has_enough_balance ( ctx . price ): ... return Success () ... else : ... return Failure () ... ... def __init__ ( self , load_profile , load_price ): ... ... self . load_profile = load_profile ... self . load_price = load_price >>> from app.db import ProfileTable , PriceTable >>> def load_profile ( profile_id ): ... return ProfileTable . where ( pk = profile_id ) . select () >>> def load_price ( price_id ): ... return PriceTable . where ( pk = price_id ) . select () >>> Subscription ( load_profile , load_price ) . buy ( profile_id = 1 , price_id = 7 ) async >>> class Subscription : ... ... @story ... @arguments ( \"profile_id\" , \"price_id\" ) ... def buy ( I ): ... ... I . find_profile ... I . find_price ... I . check_balance ... ... async def find_profile ( self , ctx ): ... ... ctx . profile = await self . load_profile ( ctx . profile_id ) ... return Success () ... ... async def find_price ( self , ctx ): ... ... ctx . price = await self . load_price ( ctx . price_id ) ... return Success () ... ... async def check_balance ( self , ctx ): ... ... if ctx . profile . has_enough_balance ( ctx . price ): ... return Success () ... else : ... return Failure () ... ... def __init__ ( self , load_profile , load_price ): ... ... self . load_profile = load_profile ... self . load_price = load_price >>> import asyncio >>> from aioapp.db import ProfileTable , PriceTable >>> async def load_profile ( profile_id ): ... return await ProfileTable . where ( pk = profile_id ) . select () >>> async def load_price ( price_id ): ... return await PriceTable . where ( pk = price_id ) . select () >>> asyncio . run ( Subscription ( load_profile , load_price ) . buy ( profile_id = 1 , price_id = 7 )) This way you decouple your business logic from relation mapper models or networking library! There is no more vendor lock on a certain framework or database! Welcome to the good architecture utopia. You can group delegates into a single object to avoid complex constructors and names duplication. sync >>> def find_price ( self , ctx ): ... ctx . price = self . impl . find_price ( ctx . price_id ) ... return Success () >>> def __init__ ( self , impl ): ... self . impl = impl async >>> async def find_price ( self , ctx ): ... ctx . price = await self . impl . find_price ( ctx . price_id ) ... return Success () >>> def __init__ ( self , impl ): ... self . impl = impl If you follow our mantra \"decouple everything\", you definitely should check the following libraries: dependencies attrs dataclasses \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Delegate implementation"},{"location":"debugging/","text":"Debugging \u00b6 There is no perfect code. Here is the technique we use to debug our own code written with stories . Code \u00b6 Our regular story looks like this. You can read more on this topic here . >>> from stories import story , arguments , Success , Skip , Result >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category_id\" ) ... def apply ( I ): ... ... I . find_category ... I . find_promo_code ... I . check_expiration ... I . calculate_discount ... I . show_final_price ... ... # Steps. ... ... def find_category ( self , ctx ): ... ... ctx . category = self . load_category ( ctx . category_id ) ... return Success () ... ... def find_promo_code ( self , ctx ): ... ... ctx . promo_code = self . load_promo_code ( ctx . category ) ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Skip () ... else : ... return Success () ... ... def calculate_discount ( self , ctx ): ... ... ctx . discount = ctx . promo_code . apply_discount ( ctx . category . price ) ... return Success () ... ... def show_final_price ( self , ctx ): ... ... return Result ( ctx . category . price - ctx . discount ) ... ... # Dependencies. ... ... def __init__ ( self , load_category , load_promo_code ): ... ... self . load_category = load_category ... self . load_promo_code = load_promo_code >>> class Category : ... ... def __init__ ( self , price = None , name = None , ** kwargs ): ... ... self . price = price ... self . name = name ... for k , v in kwargs . items (): ... setattr ( self , k , v ) >>> class PromoCode : ... ... def __init__ ( self , percent ): ... ... self . fraction = percent / 100 ... ... def is_expired ( self ): ... ... return False ... ... def apply_discount ( self , price ): ... ... return price * self . fraction It defines top-level logic without any implementation detail written in story methods. We provide an implementation in a separate set of functions. >>> def load_category ( category_id ): ... return Category ( orice = 715 , category_id = category_id ) >>> def load_promo_code ( category ): ... return PromoCode ( percent = 5 ) The first run \u00b6 Looks good at the first view. Isn't it? Let's try to run this code. >>> promo_code = ApplyPromoCode ( load_category , load_promo_code ) >>> result = promo_code . apply ( category_id = 1024 ) Traceback (most recent call last): ... TypeError : unsupported operand type(s) for *: 'NoneType' and 'float' Oops... It's broken... PDB walks into the bar \u00b6 We can take the magnifying glass and read through the whole source code meticulously. But let\u2019s try to use a debugger instead! Type this in the same console right after traceback. >>> import pdb >>> pdb . pm () # doctest: +SKIP > example.py(73)apply_discount() -> return price * self.fraction (Pdb) ll 71 def apply_discount(self, price): 72 73 -> return price * self.fraction (Pdb) args self = <example.PromoCode> price = None It's clear it isn't our fault. Someone passes a wrong value to us. We'll go one frame upper in the call stack and look who does it. (Pdb) up > example.py(38)calculate_discount() -> discount = ctx.promo_code.apply_discount(ctx.category.price) (Pdb) ll 36 def calculate_discount(self, ctx): 37 38 -> ctx.discount = ctx.promo_code.apply_discount(ctx.category.price) 39 return Success() We can clearly see that the price attribute of the category context variable is None . But who set it this way? PDB has no answer to that. At this point usually, you will re-run the whole process to stop debugger earlier trying to find the place in your code where this None was defined. But fortunately, we're using stories ! Its context has the full support of the introspection. Let's print story context at the moment of the failure. (Pdb) p ctx ApplyPromoCode.apply find_category find_promo_code check_expiration calculate_discount (errored: TypeError) Context: category_id = 1024 # Story argument category = <example.Category> # Set by ApplyPromoCode.find_category promo_code = <example.PromoCode> # Set by ApplyPromoCode.find_promo_code We can tell that category was defined by find_category step. Let's take a closer look at it. >>> def find_category ( self , ctx ): ... ctx . category = self . load_category ( ctx . category_id ) ... return Success () What are the load_category stands for? (Pdb) p self.load_category <function load_category> (Pdb) p dir(ctx.category) ['category_id', 'name', 'orice', 'price'] These orice and price attribute looks suspicious. >>> def load_category ( category_id ): ... return Category ( orice = 715 , category_id = category_id ) ... # `---- Root of all evil. So we can quickly find mistyped argument name in the Category constructor. The second run \u00b6 Let's fix it. >>> def load_category ( category_id ): ... return Category ( price = 715 , category_id = category_id ) And re-run our program. >>> promo_code = ApplyPromoCode ( load_category , load_promo_code ) >>> result = promo_code . apply ( category_id = 1024 ) >>> result 679.25 Hooray! It works. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Debugging"},{"location":"debugging/#debugging","text":"There is no perfect code. Here is the technique we use to debug our own code written with stories .","title":"Debugging"},{"location":"debugging/#code","text":"Our regular story looks like this. You can read more on this topic here . >>> from stories import story , arguments , Success , Skip , Result >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category_id\" ) ... def apply ( I ): ... ... I . find_category ... I . find_promo_code ... I . check_expiration ... I . calculate_discount ... I . show_final_price ... ... # Steps. ... ... def find_category ( self , ctx ): ... ... ctx . category = self . load_category ( ctx . category_id ) ... return Success () ... ... def find_promo_code ( self , ctx ): ... ... ctx . promo_code = self . load_promo_code ( ctx . category ) ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Skip () ... else : ... return Success () ... ... def calculate_discount ( self , ctx ): ... ... ctx . discount = ctx . promo_code . apply_discount ( ctx . category . price ) ... return Success () ... ... def show_final_price ( self , ctx ): ... ... return Result ( ctx . category . price - ctx . discount ) ... ... # Dependencies. ... ... def __init__ ( self , load_category , load_promo_code ): ... ... self . load_category = load_category ... self . load_promo_code = load_promo_code >>> class Category : ... ... def __init__ ( self , price = None , name = None , ** kwargs ): ... ... self . price = price ... self . name = name ... for k , v in kwargs . items (): ... setattr ( self , k , v ) >>> class PromoCode : ... ... def __init__ ( self , percent ): ... ... self . fraction = percent / 100 ... ... def is_expired ( self ): ... ... return False ... ... def apply_discount ( self , price ): ... ... return price * self . fraction It defines top-level logic without any implementation detail written in story methods. We provide an implementation in a separate set of functions. >>> def load_category ( category_id ): ... return Category ( orice = 715 , category_id = category_id ) >>> def load_promo_code ( category ): ... return PromoCode ( percent = 5 )","title":"Code"},{"location":"debugging/#the-first-run","text":"Looks good at the first view. Isn't it? Let's try to run this code. >>> promo_code = ApplyPromoCode ( load_category , load_promo_code ) >>> result = promo_code . apply ( category_id = 1024 ) Traceback (most recent call last): ... TypeError : unsupported operand type(s) for *: 'NoneType' and 'float' Oops... It's broken...","title":"The first run"},{"location":"debugging/#pdb-walks-into-the-bar","text":"We can take the magnifying glass and read through the whole source code meticulously. But let\u2019s try to use a debugger instead! Type this in the same console right after traceback. >>> import pdb >>> pdb . pm () # doctest: +SKIP > example.py(73)apply_discount() -> return price * self.fraction (Pdb) ll 71 def apply_discount(self, price): 72 73 -> return price * self.fraction (Pdb) args self = <example.PromoCode> price = None It's clear it isn't our fault. Someone passes a wrong value to us. We'll go one frame upper in the call stack and look who does it. (Pdb) up > example.py(38)calculate_discount() -> discount = ctx.promo_code.apply_discount(ctx.category.price) (Pdb) ll 36 def calculate_discount(self, ctx): 37 38 -> ctx.discount = ctx.promo_code.apply_discount(ctx.category.price) 39 return Success() We can clearly see that the price attribute of the category context variable is None . But who set it this way? PDB has no answer to that. At this point usually, you will re-run the whole process to stop debugger earlier trying to find the place in your code where this None was defined. But fortunately, we're using stories ! Its context has the full support of the introspection. Let's print story context at the moment of the failure. (Pdb) p ctx ApplyPromoCode.apply find_category find_promo_code check_expiration calculate_discount (errored: TypeError) Context: category_id = 1024 # Story argument category = <example.Category> # Set by ApplyPromoCode.find_category promo_code = <example.PromoCode> # Set by ApplyPromoCode.find_promo_code We can tell that category was defined by find_category step. Let's take a closer look at it. >>> def find_category ( self , ctx ): ... ctx . category = self . load_category ( ctx . category_id ) ... return Success () What are the load_category stands for? (Pdb) p self.load_category <function load_category> (Pdb) p dir(ctx.category) ['category_id', 'name', 'orice', 'price'] These orice and price attribute looks suspicious. >>> def load_category ( category_id ): ... return Category ( orice = 715 , category_id = category_id ) ... # `---- Root of all evil. So we can quickly find mistyped argument name in the Category constructor.","title":"PDB walks into the bar"},{"location":"debugging/#the-second-run","text":"Let's fix it. >>> def load_category ( category_id ): ... return Category ( price = 715 , category_id = category_id ) And re-run our program. >>> promo_code = ApplyPromoCode ( load_category , load_promo_code ) >>> result = promo_code . apply ( category_id = 1024 ) >>> result 679.25 Hooray! It works. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"The second run"},{"location":"definition/","text":"Definition \u00b6 Technically speaking, a story is a method of the class which calls other methods of this class in special order. The body of the story isn't executed directly. It's used as a spec of what should happen. The main purpose of it is to describe the intent. The steps of the story could be either regular methods or coroutines. This could not be mixed. All methods of the story should be of one type. If steps of the story are coroutines, you can await the story itself. Basics \u00b6 As you can see, it is a business process of the subscription to our service. sync >>> from stories import Failure , Result , Success , arguments , story >>> class Subscription : ... \"\"\"Buy subscription for certain category.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"price_id\" , \"user_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification ... I . show_category ... ... def find_category ( self , ctx ): ... ... ctx . category = load_category ( ctx . category_id ) ... return Success () ... ... def find_price ( self , ctx ): ... ... ctx . price = load_price ( ctx . price_id ) ... return Success () ... ... def find_profile ( self , ctx ): ... ... ctx . profile = load_profile ( ctx . user_id ) ... return Success () ... ... def check_balance ( self , ctx ): ... ... if ctx . profile . balance > ctx . price . cost : ... return Success () ... else : ... return Failure () ... ... def persist_payment ( self , ctx ): ... ... decrease_balance ( ctx . profile , ctx . price . cost ) ... save_profile ( ctx . profile ) ... return Success () ... ... def persist_subscription ( self , ctx ): ... ... expires = calculate_period ( ctx . price . period ) ... ctx . subscription = create_subscription ( ... ctx . profile , ctx . category , expires ... ) ... return Success () ... ... def send_subscription_notification ( self , ctx ): ... ... ctx . notification = send_notification ( ... \"subscription\" , ctx . profile , ctx . category . name ... ) ... return Success () ... ... def show_category ( self , ctx ): ... ... return Result ( ctx . category ) async >>> from stories import Failure , Result , Success , arguments , story >>> class Subscription : ... \"\"\"Buy subscription for certain category.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"price_id\" , \"user_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification ... I . show_category ... ... async def find_category ( self , ctx ): ... ... ctx . category = await load_category ( ctx . category_id ) ... return Success () ... ... async def find_price ( self , ctx ): ... ... ctx . price = await load_price ( ctx . price_id ) ... return Success () ... ... async def find_profile ( self , ctx ): ... ... ctx . profile = await load_profile ( ctx . user_id ) ... return Success () ... ... async def check_balance ( self , ctx ): ... ... if ctx . profile . balance > ctx . price . cost : ... return Success () ... else : ... return Failure () ... ... async def persist_payment ( self , ctx ): ... ... await decrease_balance ( ctx . profile , ctx . price . cost ) ... await save_profile ( ctx . profile ) ... return Success () ... ... async def persist_subscription ( self , ctx ): ... ... expires = await calculate_period ( ctx . price . period ) ... ctx . subscription = await create_subscription ( ... ctx . profile , ctx . category , expires ... ) ... return Success () ... ... async def send_subscription_notification ( self , ctx ): ... ... ctx . notification = await send_notification ( ... \"subscription\" , ctx . profile , ctx . category . name ... ) ... return Success () ... ... async def show_category ( self , ctx ): ... ... return Result ( ctx . category ) Explanation \u00b6 There are a few terms you should be familiar with: @story decorated method represents the spec of the business process. It's executed only once at the class definition moment. This class attribute became a smart business object. @arguments decorator describes input data similar to function arguments. I object is used to build the execution spec out of its attributes. You can use any human-readable names. Methods defined in the class are story steps. They will be called by the smart business object defined with the @story decorator. Usually, they just delegate responsibility to the call of other function with proper variables from the context. self in step methods is the real instance of the Subscription class. You own this class. It's up to you how to write it. The smart business object will use its instance to resolve its steps. ctx is a scope of variables available to step methods. Context is initiated from input data passed to the business object. It can be extended by previously executed step methods with keyword arguments to the Success() marker. Success , Failure and Result are markers returned by step methods to change business process execution path. Invalid story definitions \u00b6 Some story definitions are invalid. If such a story is defined it may raise an error whenever the @story decorator wraps the story definition method or whenever you run it, depending on the invalid story in question. Story definitions which return a coroutine \u00b6 The story definition method itself must not be declared with async def Attempting to do so will raise a StoryDefinitionError . sync >>> from stories import Success , story >>> class InvalidStoryDefinition : ... \"\"\"An example of an invalid story that is defined using `async def`.\"\"\" ... ... @story ... async def example ( I ): ... ... I . step ... ... def step ( self , ctx ): ... ... return Success () Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Story should be a regular function async >>> from stories import Success , story >>> class InvalidStoryDefinition : ... \"\"\"An example of an invalid story that is defined using `async def`.\"\"\" ... ... @story ... async def example ( I ): ... ... I . step ... ... async def step ( self , ctx ): ... ... return Success () Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Story should be a regular function Explanation \u00b6 Building a story is a synchronous operation. If a story definition method were to return a coroutine, it would leak since since it is never await ed. Empty Stories \u00b6 Story definitions without any steps are invalid Attempting to define such a story will raise a StoryDefinitionError . >>> from stories import story >>> class EmptyStory : ... \"\"\"An example of an empty story.\"\"\" ... ... @story ... def empty ( I ): ... ... pass Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Story should have at least one step defined Explanation \u00b6 Stories without any steps are meaningless. Their result is unclear and they serve no purpose. We require you to define at least one step to determine whether the story is synchronous or asynchronous. Mixing synchronous steps and asynchronous steps \u00b6 All steps must either be synchronous or asynchronous Attempting to access a story with synchronous steps or sub-stories which contain such steps will raise a StoryDefinitionError . sync >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid synchrnous story that incorporates an asynchronous step.\"\"\" ... ... @story ... def example ( I ): ... ... I . synchronous_step ... I . asynchronous_step ... ... def synchronous_step ( self , ctx ): ... ... return Success () ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutines and functions can not be used together in story definition. <BLANKLINE> This method should be a function: MixedStory.asynchronous_step <BLANKLINE> Story method: MixedStory.example async >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid asynchrnous story that incorporates an synchronous step.\"\"\" ... ... @story ... def example ( I ): ... ... I . asynchronous_step ... I . synchronous_step ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () ... ... def synchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutines and functions can not be used together in story definition. <BLANKLINE> This method should be a coroutine: MixedStory.synchronous_step <BLANKLINE> Story method: MixedStory.example Likewise, injecting a synchronous sub-story to an asynchronous story or the contrary is also forbidden. sync >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid synchrnous story that incorporates an asynchronous sub-story.\"\"\" ... ... @story ... def example ( I ): ... ... I . synchronous_step ... I . asynchronous_substory ... ... def synchronous_step ( self , ctx ): ... ... return Success () ... ... def __init__ ( self ): ... ... self . asynchronous_substory = MixedSubstory () . asynchronous_substory >>> class MixedSubstory : ... ... @story ... def asynchronous_substory ( I ): ... ... I . asynchronous_step ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutine and function stories can not be injected into each other. <BLANKLINE> Story function method: MixedStory.example <BLANKLINE> Substory coroutine method: MixedSubstory.asynchronous_substory async >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid synchrnous story that incorporates an asynchronous sub-story.\"\"\" ... ... @story ... def example ( I ): ... ... I . asynchronous_step ... I . synchronous_substory ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () ... ... def __init__ ( self ): ... ... self . synchronous_substory = MixedSubstory () . synchronous_substory >>> class MixedSubstory : ... ... @story ... def synchronous_substory ( I ): ... ... I . synchronous_step ... ... def synchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutine and function stories can not be injected into each other. <BLANKLINE> Story coroutine method: MixedStory.example <BLANKLINE> Substory function method: MixedSubstory.synchronous_substory Explanation \u00b6 Running a synchronous step or sub-story in an asynchronous story may block the event loop. If the event loop is blocked for too long the program's performance might suffer. Running a asynchronous step or sub-story in an synchronous story will cause an error since the step returns a coroutine which is not one of the accepted return types for a step or a sub-story. In addition it will cause a coroutine leak since we don't await it. Note This is a limitation that will be lifted by a future version. When defining an asynchronous story, we will require you to explictly specify that the synchronous step or sub-story will execute in a worker thread. Likewise, when defining a synchronous story, we will require you to explictly specify that the asynchronous step or sub-story will execute in an event loop. Failure protocols \u00b6 To make failure handling a more manageable process we can define a failure protocol . sync >>> from enum import Enum , auto >>> from stories import Failure , Result , Success , arguments , story >>> class ShowCategory : ... \"\"\"Show category entries.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"user_id\" ) ... def show ( I ): ... ... I . find_subscription ... I . check_expiration ... I . find_category ... I . show_category ... ... def find_subscription ( self , ctx ): ... ... subscription = load_subscription ( ctx . category_id , ctx . user_id ) ... if subscription : ... ctx . subscription = subscription ... return Success () ... else : ... return Failure ( Errors . forbidden ) ... ... def check_expiration ( self , ctx ): ... ... if ctx . subscription . is_expired (): ... return Failure ( Errors . forbidden ) ... else : ... return Success () ... ... def find_category ( self , ctx ): ... ... category = load_category ( ctx . category_id ) ... if category : ... ctx . category = category ... return Success () ... else : ... return Failure ( Errors . not_found ) ... ... def show_category ( self , ctx ): ... ... return Result ( ctx . category ) >>> @ShowCategory . show . failures ... class Errors ( Enum ): ... ... forbidden = auto () ... not_found = auto () async >>> from enum import Enum , auto >>> from stories import Failure , Result , Success , arguments , story >>> class ShowCategory : ... \"\"\"Show category entries.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"user_id\" ) ... def show ( I ): ... ... I . find_subscription ... I . check_expiration ... I . find_category ... I . show_category ... ... async def find_subscription ( self , ctx ): ... ... subscription = await load_subscription ( ctx . category_id , ctx . user_id ) ... if subscription : ... ctx . subscription = subscription ... return Success () ... else : ... return Failure ( Errors . forbidden ) ... ... async def check_expiration ( self , ctx ): ... ... if await ctx . subscription . is_expired (): ... return Failure ( Errors . forbidden ) ... else : ... return Success () ... ... async def find_category ( self , ctx ): ... ... category = await load_category ( ctx . category_id ) ... if category : ... ctx . category = category ... return Success () ... else : ... return Failure ( Errors . not_found ) ... ... async def show_category ( self , ctx ): ... ... return Result ( ctx . category ) >>> @ShowCategory . show . failures ... class Errors ( Enum ): ... ... forbidden = auto () ... not_found = auto () Explanation \u00b6 Failure marker takes optional reason argument. It can be used in the caller code to handle this failure. For example, to show a proper error code to the user. Failure protocol should be defined after the story to allow passing reason in the Failure marker. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Definition"},{"location":"definition/#definition","text":"Technically speaking, a story is a method of the class which calls other methods of this class in special order. The body of the story isn't executed directly. It's used as a spec of what should happen. The main purpose of it is to describe the intent. The steps of the story could be either regular methods or coroutines. This could not be mixed. All methods of the story should be of one type. If steps of the story are coroutines, you can await the story itself.","title":"Definition"},{"location":"definition/#basics","text":"As you can see, it is a business process of the subscription to our service. sync >>> from stories import Failure , Result , Success , arguments , story >>> class Subscription : ... \"\"\"Buy subscription for certain category.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"price_id\" , \"user_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification ... I . show_category ... ... def find_category ( self , ctx ): ... ... ctx . category = load_category ( ctx . category_id ) ... return Success () ... ... def find_price ( self , ctx ): ... ... ctx . price = load_price ( ctx . price_id ) ... return Success () ... ... def find_profile ( self , ctx ): ... ... ctx . profile = load_profile ( ctx . user_id ) ... return Success () ... ... def check_balance ( self , ctx ): ... ... if ctx . profile . balance > ctx . price . cost : ... return Success () ... else : ... return Failure () ... ... def persist_payment ( self , ctx ): ... ... decrease_balance ( ctx . profile , ctx . price . cost ) ... save_profile ( ctx . profile ) ... return Success () ... ... def persist_subscription ( self , ctx ): ... ... expires = calculate_period ( ctx . price . period ) ... ctx . subscription = create_subscription ( ... ctx . profile , ctx . category , expires ... ) ... return Success () ... ... def send_subscription_notification ( self , ctx ): ... ... ctx . notification = send_notification ( ... \"subscription\" , ctx . profile , ctx . category . name ... ) ... return Success () ... ... def show_category ( self , ctx ): ... ... return Result ( ctx . category ) async >>> from stories import Failure , Result , Success , arguments , story >>> class Subscription : ... \"\"\"Buy subscription for certain category.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"price_id\" , \"user_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification ... I . show_category ... ... async def find_category ( self , ctx ): ... ... ctx . category = await load_category ( ctx . category_id ) ... return Success () ... ... async def find_price ( self , ctx ): ... ... ctx . price = await load_price ( ctx . price_id ) ... return Success () ... ... async def find_profile ( self , ctx ): ... ... ctx . profile = await load_profile ( ctx . user_id ) ... return Success () ... ... async def check_balance ( self , ctx ): ... ... if ctx . profile . balance > ctx . price . cost : ... return Success () ... else : ... return Failure () ... ... async def persist_payment ( self , ctx ): ... ... await decrease_balance ( ctx . profile , ctx . price . cost ) ... await save_profile ( ctx . profile ) ... return Success () ... ... async def persist_subscription ( self , ctx ): ... ... expires = await calculate_period ( ctx . price . period ) ... ctx . subscription = await create_subscription ( ... ctx . profile , ctx . category , expires ... ) ... return Success () ... ... async def send_subscription_notification ( self , ctx ): ... ... ctx . notification = await send_notification ( ... \"subscription\" , ctx . profile , ctx . category . name ... ) ... return Success () ... ... async def show_category ( self , ctx ): ... ... return Result ( ctx . category )","title":"Basics"},{"location":"definition/#explanation","text":"There are a few terms you should be familiar with: @story decorated method represents the spec of the business process. It's executed only once at the class definition moment. This class attribute became a smart business object. @arguments decorator describes input data similar to function arguments. I object is used to build the execution spec out of its attributes. You can use any human-readable names. Methods defined in the class are story steps. They will be called by the smart business object defined with the @story decorator. Usually, they just delegate responsibility to the call of other function with proper variables from the context. self in step methods is the real instance of the Subscription class. You own this class. It's up to you how to write it. The smart business object will use its instance to resolve its steps. ctx is a scope of variables available to step methods. Context is initiated from input data passed to the business object. It can be extended by previously executed step methods with keyword arguments to the Success() marker. Success , Failure and Result are markers returned by step methods to change business process execution path.","title":"Explanation"},{"location":"definition/#invalid-story-definitions","text":"Some story definitions are invalid. If such a story is defined it may raise an error whenever the @story decorator wraps the story definition method or whenever you run it, depending on the invalid story in question.","title":"Invalid story definitions"},{"location":"definition/#story-definitions-which-return-a-coroutine","text":"The story definition method itself must not be declared with async def Attempting to do so will raise a StoryDefinitionError . sync >>> from stories import Success , story >>> class InvalidStoryDefinition : ... \"\"\"An example of an invalid story that is defined using `async def`.\"\"\" ... ... @story ... async def example ( I ): ... ... I . step ... ... def step ( self , ctx ): ... ... return Success () Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Story should be a regular function async >>> from stories import Success , story >>> class InvalidStoryDefinition : ... \"\"\"An example of an invalid story that is defined using `async def`.\"\"\" ... ... @story ... async def example ( I ): ... ... I . step ... ... async def step ( self , ctx ): ... ... return Success () Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Story should be a regular function","title":"Story definitions which return a coroutine"},{"location":"definition/#explanation_1","text":"Building a story is a synchronous operation. If a story definition method were to return a coroutine, it would leak since since it is never await ed.","title":"Explanation"},{"location":"definition/#empty-stories","text":"Story definitions without any steps are invalid Attempting to define such a story will raise a StoryDefinitionError . >>> from stories import story >>> class EmptyStory : ... \"\"\"An example of an empty story.\"\"\" ... ... @story ... def empty ( I ): ... ... pass Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Story should have at least one step defined","title":"Empty Stories"},{"location":"definition/#explanation_2","text":"Stories without any steps are meaningless. Their result is unclear and they serve no purpose. We require you to define at least one step to determine whether the story is synchronous or asynchronous.","title":"Explanation"},{"location":"definition/#mixing-synchronous-steps-and-asynchronous-steps","text":"All steps must either be synchronous or asynchronous Attempting to access a story with synchronous steps or sub-stories which contain such steps will raise a StoryDefinitionError . sync >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid synchrnous story that incorporates an asynchronous step.\"\"\" ... ... @story ... def example ( I ): ... ... I . synchronous_step ... I . asynchronous_step ... ... def synchronous_step ( self , ctx ): ... ... return Success () ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutines and functions can not be used together in story definition. <BLANKLINE> This method should be a function: MixedStory.asynchronous_step <BLANKLINE> Story method: MixedStory.example async >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid asynchrnous story that incorporates an synchronous step.\"\"\" ... ... @story ... def example ( I ): ... ... I . asynchronous_step ... I . synchronous_step ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () ... ... def synchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutines and functions can not be used together in story definition. <BLANKLINE> This method should be a coroutine: MixedStory.synchronous_step <BLANKLINE> Story method: MixedStory.example Likewise, injecting a synchronous sub-story to an asynchronous story or the contrary is also forbidden. sync >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid synchrnous story that incorporates an asynchronous sub-story.\"\"\" ... ... @story ... def example ( I ): ... ... I . synchronous_step ... I . asynchronous_substory ... ... def synchronous_step ( self , ctx ): ... ... return Success () ... ... def __init__ ( self ): ... ... self . asynchronous_substory = MixedSubstory () . asynchronous_substory >>> class MixedSubstory : ... ... @story ... def asynchronous_substory ( I ): ... ... I . asynchronous_step ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutine and function stories can not be injected into each other. <BLANKLINE> Story function method: MixedStory.example <BLANKLINE> Substory coroutine method: MixedSubstory.asynchronous_substory async >>> from stories import Success , story >>> class MixedStory : ... \"\"\"An example of an invalid synchrnous story that incorporates an asynchronous sub-story.\"\"\" ... ... @story ... def example ( I ): ... ... I . asynchronous_step ... I . synchronous_substory ... ... async def asynchronous_step ( self , ctx ): ... ... return Success () ... ... def __init__ ( self ): ... ... self . synchronous_substory = MixedSubstory () . synchronous_substory >>> class MixedSubstory : ... ... @story ... def synchronous_substory ( I ): ... ... I . synchronous_step ... ... def synchronous_step ( self , ctx ): ... ... return Success () >>> MixedStory () . example Traceback (most recent call last): ... _stories.exceptions.StoryDefinitionError : Coroutine and function stories can not be injected into each other. <BLANKLINE> Story coroutine method: MixedStory.example <BLANKLINE> Substory function method: MixedSubstory.synchronous_substory","title":"Mixing synchronous steps and asynchronous steps"},{"location":"definition/#explanation_3","text":"Running a synchronous step or sub-story in an asynchronous story may block the event loop. If the event loop is blocked for too long the program's performance might suffer. Running a asynchronous step or sub-story in an synchronous story will cause an error since the step returns a coroutine which is not one of the accepted return types for a step or a sub-story. In addition it will cause a coroutine leak since we don't await it. Note This is a limitation that will be lifted by a future version. When defining an asynchronous story, we will require you to explictly specify that the synchronous step or sub-story will execute in a worker thread. Likewise, when defining a synchronous story, we will require you to explictly specify that the asynchronous step or sub-story will execute in an event loop.","title":"Explanation"},{"location":"definition/#failure-protocols","text":"To make failure handling a more manageable process we can define a failure protocol . sync >>> from enum import Enum , auto >>> from stories import Failure , Result , Success , arguments , story >>> class ShowCategory : ... \"\"\"Show category entries.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"user_id\" ) ... def show ( I ): ... ... I . find_subscription ... I . check_expiration ... I . find_category ... I . show_category ... ... def find_subscription ( self , ctx ): ... ... subscription = load_subscription ( ctx . category_id , ctx . user_id ) ... if subscription : ... ctx . subscription = subscription ... return Success () ... else : ... return Failure ( Errors . forbidden ) ... ... def check_expiration ( self , ctx ): ... ... if ctx . subscription . is_expired (): ... return Failure ( Errors . forbidden ) ... else : ... return Success () ... ... def find_category ( self , ctx ): ... ... category = load_category ( ctx . category_id ) ... if category : ... ctx . category = category ... return Success () ... else : ... return Failure ( Errors . not_found ) ... ... def show_category ( self , ctx ): ... ... return Result ( ctx . category ) >>> @ShowCategory . show . failures ... class Errors ( Enum ): ... ... forbidden = auto () ... not_found = auto () async >>> from enum import Enum , auto >>> from stories import Failure , Result , Success , arguments , story >>> class ShowCategory : ... \"\"\"Show category entries.\"\"\" ... ... @story ... @arguments ( \"category_id\" , \"user_id\" ) ... def show ( I ): ... ... I . find_subscription ... I . check_expiration ... I . find_category ... I . show_category ... ... async def find_subscription ( self , ctx ): ... ... subscription = await load_subscription ( ctx . category_id , ctx . user_id ) ... if subscription : ... ctx . subscription = subscription ... return Success () ... else : ... return Failure ( Errors . forbidden ) ... ... async def check_expiration ( self , ctx ): ... ... if await ctx . subscription . is_expired (): ... return Failure ( Errors . forbidden ) ... else : ... return Success () ... ... async def find_category ( self , ctx ): ... ... category = await load_category ( ctx . category_id ) ... if category : ... ctx . category = category ... return Success () ... else : ... return Failure ( Errors . not_found ) ... ... async def show_category ( self , ctx ): ... ... return Result ( ctx . category ) >>> @ShowCategory . show . failures ... class Errors ( Enum ): ... ... forbidden = auto () ... not_found = auto ()","title":"Failure protocols"},{"location":"definition/#explanation_4","text":"Failure marker takes optional reason argument. It can be used in the caller code to handle this failure. For example, to show a proper error code to the user. Failure protocol should be defined after the story to allow passing reason in the Failure marker. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Explanation"},{"location":"execution/","text":"Execution rules \u00b6 stories follow this executing rules to run: Methods of the class will be called in the order as they were written in the story If the story calls another story in its body, methods of this sub-story add to the caller in the order they occur in sub-story body. Each story method should return an instance of Success , Failure , Result or Skip classes. The execution of the story will change according to the type of the return value. Success \u00b6 If the story method returns Success execution of the whole story continues from the next step. sync >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> Action () . do () one two three async >>> import asyncio >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one two three If sub-story last method returns Success , the execution continues in the next method of the parent story. sync >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> Action () . do () one two three four async >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one two three four Story method can assign attributes to the context to set some variables for future methods. sync >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... def one ( self , ctx ): ... ... ctx . var_a = 1 ... ctx . var_b = 2 ... return Success () ... ... def two ( self , ctx ): ... ... print ( ctx . var_a ) ... print ( ctx . var_b ) ... return Success () >>> Action () . do () 1 2 async >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... async def one ( self , ctx ): ... ... ctx . var_a = 1 ... ctx . var_b = 2 ... return Success () ... ... async def two ( self , ctx ): ... ... print ( ctx . var_a ) ... print ( ctx . var_b ) ... return Success () >>> asyncio . run ( Action () . do ()) 1 2 Failure \u00b6 If story method returns Failure , the whole story considered failed. Execution stops at this point. sync >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Failure () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> result = Action () . do . run () one >>> result . is_failure True async >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Failure () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> result = asyncio . run ( Action () . do . run ()) one >>> result . is_failure True Failure of the sub-story will fail the whole story. sync >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Failure () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> result = Action () . do . run () one two >>> result . is_failure True async >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Failure () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> result = asyncio . run ( Action () . do . run ()) one two >>> result . is_failure True Failure has optional reason argument. We describe it in details in the failure protocol chapter. Result \u00b6 If the story method return Result , the whole story considered done. An optional argument passed to the Result constructor will be the return value of the story call. sync >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Result ( 1 ) ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> res = Action () . do () one two >>> res 1 async >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Result ( 1 ) ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> res = asyncio . run ( Action () . do ()) one two >>> res 1 The Result of the sub-story will be the result of the whole story. The execution stops after the method returned Result . sync >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Result ( 2 ) >>> result = Action () . do () one two three >>> result 2 async >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Result ( 2 ) >>> result = asyncio . run ( Action () . do ()) one two three >>> result 2 Skip \u00b6 If sub-story method returns Skip result, execution will be continued form the next method of the caller story. sync >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Skip () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> Action () . do () one two four async >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Skip () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one two four If the topmost story returns Skip result, execution will end. sync >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Skip () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> Action () . do () one async >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Skip () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Execution"},{"location":"execution/#execution-rules","text":"stories follow this executing rules to run: Methods of the class will be called in the order as they were written in the story If the story calls another story in its body, methods of this sub-story add to the caller in the order they occur in sub-story body. Each story method should return an instance of Success , Failure , Result or Skip classes. The execution of the story will change according to the type of the return value.","title":"Execution rules"},{"location":"execution/#success","text":"If the story method returns Success execution of the whole story continues from the next step. sync >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> Action () . do () one two three async >>> import asyncio >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one two three If sub-story last method returns Success , the execution continues in the next method of the parent story. sync >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> Action () . do () one two three four async >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one two three four Story method can assign attributes to the context to set some variables for future methods. sync >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... def one ( self , ctx ): ... ... ctx . var_a = 1 ... ctx . var_b = 2 ... return Success () ... ... def two ( self , ctx ): ... ... print ( ctx . var_a ) ... print ( ctx . var_b ) ... return Success () >>> Action () . do () 1 2 async >>> from stories import story , Success >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... async def one ( self , ctx ): ... ... ctx . var_a = 1 ... ctx . var_b = 2 ... return Success () ... ... async def two ( self , ctx ): ... ... print ( ctx . var_a ) ... print ( ctx . var_b ) ... return Success () >>> asyncio . run ( Action () . do ()) 1 2","title":"Success"},{"location":"execution/#failure","text":"If story method returns Failure , the whole story considered failed. Execution stops at this point. sync >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Failure () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> result = Action () . do . run () one >>> result . is_failure True async >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Failure () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> result = asyncio . run ( Action () . do . run ()) one >>> result . is_failure True Failure of the sub-story will fail the whole story. sync >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Failure () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> result = Action () . do . run () one two >>> result . is_failure True async >>> from stories import story , Success , Failure >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Failure () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> result = asyncio . run ( Action () . do . run ()) one two >>> result . is_failure True Failure has optional reason argument. We describe it in details in the failure protocol chapter.","title":"Failure"},{"location":"execution/#result","text":"If the story method return Result , the whole story considered done. An optional argument passed to the Result constructor will be the return value of the story call. sync >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Result ( 1 ) ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> res = Action () . do () one two >>> res 1 async >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... I . three ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Result ( 1 ) ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> res = asyncio . run ( Action () . do ()) one two >>> res 1 The Result of the sub-story will be the result of the whole story. The execution stops after the method returned Result . sync >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Result ( 2 ) >>> result = Action () . do () one two three >>> result 2 async >>> from stories import story , Success , Result >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Result ( 2 ) >>> result = asyncio . run ( Action () . do ()) one two three >>> result 2","title":"Result"},{"location":"execution/#skip","text":"If sub-story method returns Skip result, execution will be continued form the next method of the caller story. sync >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Skip () ... ... def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> Action () . do () one two four async >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . sub ... I . four ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Success () ... ... async def four ( self , ctx ): ... ... print ( \"four\" ) ... return Success () ... ... def __init__ ( self ): ... ... self . sub = SubAction () . sub >>> class SubAction : ... ... @story ... def sub ( I ): ... ... I . two ... I . three ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Skip () ... ... async def three ( self , ctx ): ... ... print ( \"three\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one two four If the topmost story returns Skip result, execution will end. sync >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... def one ( self , ctx ): ... ... print ( \"one\" ) ... return Skip () ... ... def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> Action () . do () one async >>> from stories import story , Success , Skip >>> class Action : ... ... @story ... def do ( I ): ... ... I . one ... I . two ... ... async def one ( self , ctx ): ... ... print ( \"one\" ) ... return Skip () ... ... async def two ( self , ctx ): ... ... print ( \"two\" ) ... return Success () >>> asyncio . run ( Action () . do ()) one \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Skip"},{"location":"failure_protocol/","text":"Failure Protocol \u00b6 By default, Failure result has an empty reason . failed_on is the only thing you can do to understand what happened in the caller code. You should use the run the story method to have access to the verbose result. This is a fragile approach since it depends on method names. They tend to change in the future. Someone can find a better name for a certain method. And in some place, the failed_on call will not catch this failure because it's using an outdated method name. Also, one story step can fail for a number of reasons. For example, we're making an API call. We want to process 401 and 403 error codes differently. This is where failed_on method can't help. Note Failure protocol is the way to allow a certain set of values to be used as an argument to the Failure result. After that in the caller code, you can use the failed_because method to be sure you can understand the exact reason for failure. List of strings \u00b6 You can use string literals to mark the exact reason for the failure. In this case, failure protocol should be a collection of all allowed strings. You can use these string literals to process different failures in a different way. sync >>> from stories import story , arguments , Success , Failure >>> from app.entities import Category >>> from app.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... def find_promo_code ( self , ctx ): ... ... ctx . promo_code = self . load_promo_code ( ctx . category ) ... return Success () ... ... def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( \"not_found\" ) ... else : ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( \"expired\" ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> ApplyPromoCode . apply . failures ([ \"not_found\" , \"expired\" ]) ['not_found', 'expired'] >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 )) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( \"not_found\" ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( \"expired\" ): ... print ( \"Promo code expired\" ) Promo code not found async >>> import asyncio >>> from stories import story , arguments , Success , Failure >>> from app.entities import Category >>> from aioapp.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... async def find_promo_code ( self , ctx ): ... ... ctx . promo_code = await self . load_promo_code ( ctx . category ) ... return Success () ... ... async def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( \"not_found\" ) ... else : ... return Success () ... ... async def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( \"expired\" ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> ApplyPromoCode . apply . failures ([ \"not_found\" , \"expired\" ]) ['not_found', 'expired'] >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = asyncio . run ( promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 ))) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( \"not_found\" ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( \"expired\" ): ... print ( \"Promo code expired\" ) Promo code not found Enum \u00b6 You can use enum members to mark the exact reason for the failure. In this case, failure protocol should be enum subclass. You can use enum members to process different failures in a different way. sync >>> from enum import Enum , auto >>> from app.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... def find_promo_code ( self , ctx ): ... ... ctx . promo_code = self . load_promo_code ( ctx . category ) ... return Success () ... ... def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( Errors . not_found ) ... else : ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( Errors . expired ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> @ApplyPromoCode . apply . failures ... class Errors ( Enum ): ... ... not_found = auto () ... expired = auto () >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 )) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( promo_code . apply . failures . not_found ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( promo_code . apply . failures . expired ): ... print ( \"Promo code expired\" ) Promo code not found async >>> from enum import Enum , auto >>> from aioapp.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... async def find_promo_code ( self , ctx ): ... ... ctx . promo_code = await self . load_promo_code ( ctx . category ) ... return Success () ... ... async def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( Errors . not_found ) ... else : ... return Success () ... ... async def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( Errors . expired ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> @ApplyPromoCode . apply . failures ... class Errors ( Enum ): ... ... not_found = auto () ... expired = auto () >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = asyncio . run ( promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 ))) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( promo_code . apply . failures . not_found ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( promo_code . apply . failures . expired ): ... print ( \"Promo code expired\" ) Promo code not found On Python 2 you can use enum34 package: pip install enum34 When you run the story method the actual failure protocol is available under failures property of that story method. So there is no need to import Errors class in the caller code. Composition \u00b6 Failure protocols of parent and sub-story often mismatch. There is a good reason for that. Indeed they usually describe rules at different levels of abstraction. Failure of sub-story can tell us about some low-level error. And the failure of the parent story usually tells us something about high-level business rules violation. Note A story in the composition can return failures with only reasons match its own protocol. A composition of these two stories can fail both because of low_balance and expired reasons. For convenience, failures property will contain protocols composition. A new enum class. sync >>> from app.repositories import load_token >>> class Subscription : ... ... @story ... def buy ( I ): ... ... I . find_promo_code ... I . check_balance ... I . persist_payment ... I . show_category ... ... # Steps. ... ... def check_balance ( self , ctx ): ... ... if ctx . user . balance < ctx . category . price : ... return Failure ( self . Errors . low_balance ) ... else : ... return Success () ... ... def persist_payment ( self , ctx ): ... ... self . create_payment ( ctx . user , ctx . category ) ... return Success () ... ... def show_category ( self , ctx ): ... ... return Result ( ctx . category ) ... ... # Protocols. ... ... @buy . failures ... class Errors ( Enum ): ... ... low_balance = auto () ... ... # Dependencies. ... ... def __init__ ( self , find_promo_code ): ... ... self . find_promo_code = find_promo_code >>> class PromoCode : ... ... @story ... def find ( I ): ... ... I . find_token ... I . check_expiration ... I . calculate_discount ... ... # Steps. ... ... def find_token ( self , ctx ): ... ... ctx . token = self . load_token () ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . token . is_expired (): ... return Failure ( self . Errors . expired ) ... else : ... return Success () ... ... def calculate_discount ( self , ctx ): ... ... ctx . discount = ctx . token . get_discount () ... return Success () ... ... # Protocols. ... ... @find . failures ... class Errors ( Enum ): ... ... expired = auto () ... ... # Dependencies. ... ... def __init__ ( self , load_token ): ... ... self . load_token = load_token >>> promo_code = PromoCode ( load_token ) >>> subscription = Subscription ( promo_code . find ) >>> result = subscription . buy . run () >>> if result . is_success : ... print ( \"Subscribed\" ) ... elif result . failed_because ( subscription . buy . failures . low_balance ): ... print ( \"Low balance\" ) ... elif result . failed_because ( subscription . buy . failures . expired ): ... print ( \"Promo code expired\" ) Promo code expired async >>> from aioapp.repositories import load_token >>> class Subscription : ... ... @story ... def buy ( I ): ... ... I . find_promo_code ... I . check_balance ... I . persist_payment ... I . show_category ... ... # Steps. ... ... async def check_balance ( self , ctx ): ... ... if ctx . user . balance < ctx . category . price : ... return Failure ( self . Errors . low_balance ) ... else : ... return Success () ... ... async def persist_payment ( self , ctx ): ... ... await self . create_payment ( ctx . user , ctx . category ) ... return Success () ... ... async def show_category ( self , ctx ): ... ... return Result ( ctx . category ) ... ... # Protocols. ... ... @buy . failures ... class Errors ( Enum ): ... ... low_balance = auto () ... ... # Dependencies. ... ... def __init__ ( self , find_promo_code ): ... ... self . find_promo_code = find_promo_code >>> class PromoCode : ... ... @story ... def find ( I ): ... ... I . find_token ... I . check_expiration ... I . calculate_discount ... ... # Steps. ... ... async def find_token ( self , ctx ): ... ... ctx . token = await self . load_token () ... return Success () ... ... async def check_expiration ( self , ctx ): ... ... if ctx . token . is_expired (): ... return Failure ( self . Errors . expired ) ... else : ... return Success () ... ... async def calculate_discount ( self , ctx ): ... ... ctx . discount = ctx . token . get_discount () ... return Success () ... ... # Protocols. ... ... @find . failures ... class Errors ( Enum ): ... ... expired = auto () ... ... # Dependencies. ... ... def __init__ ( self , load_token ): ... ... self . load_token = load_token >>> promo_code = PromoCode ( load_token ) >>> subscription = Subscription ( promo_code . find ) >>> result = asyncio . run ( subscription . buy . run ()) >>> if result . is_success : ... print ( \"Subscribed\" ) ... elif result . failed_because ( subscription . buy . failures . low_balance ): ... print ( \"Low balance\" ) ... elif result . failed_because ( subscription . buy . failures . expired ): ... print ( \"Promo code expired\" ) Promo code expired This composition rule works both for class methods with inheritance and instance attributes with dependency injection. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Failure protocol"},{"location":"failure_protocol/#failure-protocol","text":"By default, Failure result has an empty reason . failed_on is the only thing you can do to understand what happened in the caller code. You should use the run the story method to have access to the verbose result. This is a fragile approach since it depends on method names. They tend to change in the future. Someone can find a better name for a certain method. And in some place, the failed_on call will not catch this failure because it's using an outdated method name. Also, one story step can fail for a number of reasons. For example, we're making an API call. We want to process 401 and 403 error codes differently. This is where failed_on method can't help. Note Failure protocol is the way to allow a certain set of values to be used as an argument to the Failure result. After that in the caller code, you can use the failed_because method to be sure you can understand the exact reason for failure.","title":"Failure Protocol"},{"location":"failure_protocol/#list-of-strings","text":"You can use string literals to mark the exact reason for the failure. In this case, failure protocol should be a collection of all allowed strings. You can use these string literals to process different failures in a different way. sync >>> from stories import story , arguments , Success , Failure >>> from app.entities import Category >>> from app.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... def find_promo_code ( self , ctx ): ... ... ctx . promo_code = self . load_promo_code ( ctx . category ) ... return Success () ... ... def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( \"not_found\" ) ... else : ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( \"expired\" ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> ApplyPromoCode . apply . failures ([ \"not_found\" , \"expired\" ]) ['not_found', 'expired'] >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 )) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( \"not_found\" ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( \"expired\" ): ... print ( \"Promo code expired\" ) Promo code not found async >>> import asyncio >>> from stories import story , arguments , Success , Failure >>> from app.entities import Category >>> from aioapp.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... async def find_promo_code ( self , ctx ): ... ... ctx . promo_code = await self . load_promo_code ( ctx . category ) ... return Success () ... ... async def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( \"not_found\" ) ... else : ... return Success () ... ... async def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( \"expired\" ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> ApplyPromoCode . apply . failures ([ \"not_found\" , \"expired\" ]) ['not_found', 'expired'] >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = asyncio . run ( promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 ))) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( \"not_found\" ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( \"expired\" ): ... print ( \"Promo code expired\" ) Promo code not found","title":"List of strings"},{"location":"failure_protocol/#enum","text":"You can use enum members to mark the exact reason for the failure. In this case, failure protocol should be enum subclass. You can use enum members to process different failures in a different way. sync >>> from enum import Enum , auto >>> from app.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... def find_promo_code ( self , ctx ): ... ... ctx . promo_code = self . load_promo_code ( ctx . category ) ... return Success () ... ... def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( Errors . not_found ) ... else : ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( Errors . expired ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> @ApplyPromoCode . apply . failures ... class Errors ( Enum ): ... ... not_found = auto () ... expired = auto () >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 )) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( promo_code . apply . failures . not_found ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( promo_code . apply . failures . expired ): ... print ( \"Promo code expired\" ) Promo code not found async >>> from enum import Enum , auto >>> from aioapp.repositories import load_promo_code >>> class ApplyPromoCode : ... \"\"\"Calculate actual product discount, apply it to the price.\"\"\" ... ... @story ... @arguments ( \"category\" ) ... def apply ( I ): ... ... I . find_promo_code ... I . check_promo_code_exists ... I . check_expiration ... ... # Steps. ... ... async def find_promo_code ( self , ctx ): ... ... ctx . promo_code = await self . load_promo_code ( ctx . category ) ... return Success () ... ... async def check_promo_code_exists ( self , ctx ): ... ... if ctx . promo_code is None : ... return Failure ( Errors . not_found ) ... else : ... return Success () ... ... async def check_expiration ( self , ctx ): ... ... if ctx . promo_code . is_expired (): ... return Failure ( Errors . expired ) ... else : ... return Success () ... ... # Dependencies. ... ... def __init__ ( self , load_promo_code ): ... ... self . load_promo_code = load_promo_code >>> @ApplyPromoCode . apply . failures ... class Errors ( Enum ): ... ... not_found = auto () ... expired = auto () >>> promo_code = ApplyPromoCode ( load_promo_code = load_promo_code ) >>> result = asyncio . run ( promo_code . apply . run ( category = Category ( 177 , 'Drawing' , 700 ))) >>> if result . is_success : ... print ( \"Promo code applied\" ) ... elif result . failed_because ( promo_code . apply . failures . not_found ): ... print ( \"Promo code not found\" ) ... elif result . failed_because ( promo_code . apply . failures . expired ): ... print ( \"Promo code expired\" ) Promo code not found On Python 2 you can use enum34 package: pip install enum34 When you run the story method the actual failure protocol is available under failures property of that story method. So there is no need to import Errors class in the caller code.","title":"Enum"},{"location":"failure_protocol/#composition","text":"Failure protocols of parent and sub-story often mismatch. There is a good reason for that. Indeed they usually describe rules at different levels of abstraction. Failure of sub-story can tell us about some low-level error. And the failure of the parent story usually tells us something about high-level business rules violation. Note A story in the composition can return failures with only reasons match its own protocol. A composition of these two stories can fail both because of low_balance and expired reasons. For convenience, failures property will contain protocols composition. A new enum class. sync >>> from app.repositories import load_token >>> class Subscription : ... ... @story ... def buy ( I ): ... ... I . find_promo_code ... I . check_balance ... I . persist_payment ... I . show_category ... ... # Steps. ... ... def check_balance ( self , ctx ): ... ... if ctx . user . balance < ctx . category . price : ... return Failure ( self . Errors . low_balance ) ... else : ... return Success () ... ... def persist_payment ( self , ctx ): ... ... self . create_payment ( ctx . user , ctx . category ) ... return Success () ... ... def show_category ( self , ctx ): ... ... return Result ( ctx . category ) ... ... # Protocols. ... ... @buy . failures ... class Errors ( Enum ): ... ... low_balance = auto () ... ... # Dependencies. ... ... def __init__ ( self , find_promo_code ): ... ... self . find_promo_code = find_promo_code >>> class PromoCode : ... ... @story ... def find ( I ): ... ... I . find_token ... I . check_expiration ... I . calculate_discount ... ... # Steps. ... ... def find_token ( self , ctx ): ... ... ctx . token = self . load_token () ... return Success () ... ... def check_expiration ( self , ctx ): ... ... if ctx . token . is_expired (): ... return Failure ( self . Errors . expired ) ... else : ... return Success () ... ... def calculate_discount ( self , ctx ): ... ... ctx . discount = ctx . token . get_discount () ... return Success () ... ... # Protocols. ... ... @find . failures ... class Errors ( Enum ): ... ... expired = auto () ... ... # Dependencies. ... ... def __init__ ( self , load_token ): ... ... self . load_token = load_token >>> promo_code = PromoCode ( load_token ) >>> subscription = Subscription ( promo_code . find ) >>> result = subscription . buy . run () >>> if result . is_success : ... print ( \"Subscribed\" ) ... elif result . failed_because ( subscription . buy . failures . low_balance ): ... print ( \"Low balance\" ) ... elif result . failed_because ( subscription . buy . failures . expired ): ... print ( \"Promo code expired\" ) Promo code expired async >>> from aioapp.repositories import load_token >>> class Subscription : ... ... @story ... def buy ( I ): ... ... I . find_promo_code ... I . check_balance ... I . persist_payment ... I . show_category ... ... # Steps. ... ... async def check_balance ( self , ctx ): ... ... if ctx . user . balance < ctx . category . price : ... return Failure ( self . Errors . low_balance ) ... else : ... return Success () ... ... async def persist_payment ( self , ctx ): ... ... await self . create_payment ( ctx . user , ctx . category ) ... return Success () ... ... async def show_category ( self , ctx ): ... ... return Result ( ctx . category ) ... ... # Protocols. ... ... @buy . failures ... class Errors ( Enum ): ... ... low_balance = auto () ... ... # Dependencies. ... ... def __init__ ( self , find_promo_code ): ... ... self . find_promo_code = find_promo_code >>> class PromoCode : ... ... @story ... def find ( I ): ... ... I . find_token ... I . check_expiration ... I . calculate_discount ... ... # Steps. ... ... async def find_token ( self , ctx ): ... ... ctx . token = await self . load_token () ... return Success () ... ... async def check_expiration ( self , ctx ): ... ... if ctx . token . is_expired (): ... return Failure ( self . Errors . expired ) ... else : ... return Success () ... ... async def calculate_discount ( self , ctx ): ... ... ctx . discount = ctx . token . get_discount () ... return Success () ... ... # Protocols. ... ... @find . failures ... class Errors ( Enum ): ... ... expired = auto () ... ... # Dependencies. ... ... def __init__ ( self , load_token ): ... ... self . load_token = load_token >>> promo_code = PromoCode ( load_token ) >>> subscription = Subscription ( promo_code . find ) >>> result = asyncio . run ( subscription . buy . run ()) >>> if result . is_success : ... print ( \"Subscribed\" ) ... elif result . failed_because ( subscription . buy . failures . low_balance ): ... print ( \"Low balance\" ) ... elif result . failed_because ( subscription . buy . failures . expired ): ... print ( \"Promo code expired\" ) Promo code expired This composition rule works both for class methods with inheritance and instance attributes with dependency injection. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Composition"},{"location":"faq/","text":"FAQ \u00b6 Here we'll try to explain some reasons behind our decisions. Why do we need a DSL? \u00b6 Note You can ignore convention. You can't ignore the tool. A DSL with lots of possibilities is hard to reason about and maintain. A real programming language will go the same way without much attention to the structure of your project. Instead, we want stories DSL so limited, it forces users to explain their thoughts in a straightforward linear way. All complexity will go to the implementation steps. There you'll have the whole power of the Python. Why it is too magic? \u00b6 Careful programmers tend to avoid tools built on top of meta-programming. But we still use tools like dataclasses , attrs and django orm because they improve developer experience a lot. This is what stories try very hard. Note Our goal is bringing the maximum value to your process while keeping magic at the lowest possible minimum. Why DSL does not use inheritance? \u00b6 Many tools like object relation mappers, web frameworks and task queues use inheritance from some base class as the core of API. We saw a few problems with this approach. First of all, you tend to put your business logic inside this subclasses. Fighting this evil was the initial idea behind stories library. Also, this approach restricts your possibilities to manage your own classes. We want you to be free at the decisions to put story definition anywhere. It is your right to place it inside the Django Model. What is the best way to prototype my own DSL version? \u00b6 We receive a lot of complains and suggestions related to the DSL look and feel. We are open to all ideas! Please, experiment with DSL more! If you want to try to build another DSL version with the same semantics, here are the quickest way to prototype it: There is examples module in tests, where all possible DSL expressions were written down. Rewrite each expression in your version of the DSL. Implement DSL inside stories module without touching a single line of tests. Let us know if you stuck! We can do the redesign together! Why we need @arguments decorator instead of function arguments? \u00b6 For the simplicity of implementation inside @story decorator. Otherwise, we will need to use inspect library to call the function. Can I use self instead of I argument? \u00b6 Yes, you are free to use whatever name you want. We use this convention in our documentation and examples to keep in mind that I , self and ctx are three different things. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"FAQ"},{"location":"faq/#faq","text":"Here we'll try to explain some reasons behind our decisions.","title":"FAQ"},{"location":"faq/#why-do-we-need-a-dsl","text":"Note You can ignore convention. You can't ignore the tool. A DSL with lots of possibilities is hard to reason about and maintain. A real programming language will go the same way without much attention to the structure of your project. Instead, we want stories DSL so limited, it forces users to explain their thoughts in a straightforward linear way. All complexity will go to the implementation steps. There you'll have the whole power of the Python.","title":"Why do we need a DSL?"},{"location":"faq/#why-it-is-too-magic","text":"Careful programmers tend to avoid tools built on top of meta-programming. But we still use tools like dataclasses , attrs and django orm because they improve developer experience a lot. This is what stories try very hard. Note Our goal is bringing the maximum value to your process while keeping magic at the lowest possible minimum.","title":"Why it is too magic?"},{"location":"faq/#why-dsl-does-not-use-inheritance","text":"Many tools like object relation mappers, web frameworks and task queues use inheritance from some base class as the core of API. We saw a few problems with this approach. First of all, you tend to put your business logic inside this subclasses. Fighting this evil was the initial idea behind stories library. Also, this approach restricts your possibilities to manage your own classes. We want you to be free at the decisions to put story definition anywhere. It is your right to place it inside the Django Model.","title":"Why DSL does not use inheritance?"},{"location":"faq/#what-is-the-best-way-to-prototype-my-own-dsl-version","text":"We receive a lot of complains and suggestions related to the DSL look and feel. We are open to all ideas! Please, experiment with DSL more! If you want to try to build another DSL version with the same semantics, here are the quickest way to prototype it: There is examples module in tests, where all possible DSL expressions were written down. Rewrite each expression in your version of the DSL. Implement DSL inside stories module without touching a single line of tests. Let us know if you stuck! We can do the redesign together!","title":"What is the best way to prototype my own DSL version?"},{"location":"faq/#why-we-need-arguments-decorator-instead-of-function-arguments","text":"For the simplicity of implementation inside @story decorator. Otherwise, we will need to use inspect library to call the function.","title":"Why we need @arguments decorator instead of function arguments?"},{"location":"faq/#can-i-use-self-instead-of-i-argument","text":"Yes, you are free to use whatever name you want. We use this convention in our documentation and examples to keep in mind that I , self and ctx are three different things. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Can I use self instead of I argument?"},{"location":"usage/","text":"Usage \u00b6 There are several methods to use business object defined with the @story decorator. Call \u00b6 The most simple variant to execute story is to call it as a regular method. Result \u00b6 sync >>> from app.services import Subscription >>> Subscription () . buy ( category_id = 1 , price_id = 1 , profile_id = 1 ) Category(primary_key=1, name='Books', cost=7) async >>> import asyncio >>> from aioapp.services import Subscription >>> asyncio . run ( Subscription () . buy ( category_id = 1 , price_id = 1 , profile_id = 1 )) Category(primary_key=1, name='Books', cost=7) The story was executed successfully. It returns an object we put into Result marker. Failure \u00b6 sync >>> from app.services import Subscription >>> Subscription () . buy ( category_id = 2 , price_id = 2 , profile_id = 1 ) Traceback (most recent call last): ... _stories.exceptions.FailureError async >>> from aioapp.services import Subscription >>> asyncio . run ( Subscription () . buy ( category_id = 2 , price_id = 2 , profile_id = 1 )) Traceback (most recent call last): ... _stories.exceptions.FailureError Story failed. The user does not have enough money to complete this purchase. Failure marker throws an exception when call method was used. Run \u00b6 A more powerful way to inspect the result of the story is to use the run method instead. The run method always returns an object. This object contains a summary of the business object execution. Result \u00b6 sync >>> from app.services import ShowCategory >>> result = ShowCategory () . show . run ( category_id = 1 , profile_id = 1 ) >>> result . is_success True >>> result . value Category(primary_key=1, name='Books', cost=7) async >>> import asyncio >>> from aioapp.services import ShowCategory >>> result = asyncio . run ( ShowCategory () . show . run ( category_id = 1 , profile_id = 1 )) >>> result . is_success True >>> result . value Category(primary_key=1, name='Books', cost=7) If the story was executed successfully, its actual result will be available in the value attribute. Failure \u00b6 sync >>> from app.services import ShowCategory >>> result = ShowCategory () . show . run ( category_id = 2 , profile_id = 1 ) >>> result . is_failure True >>> result . failed_on ( \"check_expiration\" ) True >>> result . failed_because ( ShowCategory () . show . failures . forbidden ) True >>> result . ctx ShowCategory.show find_subscription check_expiration (failed: <Errors.forbidden: 1>) <BLANKLINE> Context: category_id: 2 # Story argument profile_id: 1 # Story argument subscription: Subscription(primary_key=7) # Set by ShowCategory.find_subscription >>> result . ctx . subscription . is_expired () True >>> result . ctx . subscription . created datetime.date(2019, 1, 1) async >>> from aioapp.services import ShowCategory >>> result = asyncio . run ( ShowCategory () . show . run ( category_id = 2 , profile_id = 1 )) >>> result . is_failure True >>> result . failed_on ( \"check_expiration\" ) True >>> result . failed_because ( ShowCategory () . show . failures . forbidden ) True >>> result . ctx ShowCategory.show find_subscription check_expiration (failed: <Errors.forbidden: 1>) <BLANKLINE> Context: category_id: 2 # Story argument profile_id: 1 # Story argument subscription: Subscription(primary_key=7) # Set by ShowCategory.find_subscription >>> result . ctx . subscription . is_expired () True >>> result . ctx . subscription . created datetime.date(2019, 1, 1) run does not raise an error. Even if the story returns Failure marker. Instead, you can use methods like failed_on and failed_because to look for failed story method and exact reason. The argument used in the failed_because method will be described in more details in the failure protocol chapter. The context of the failed story is also available in the result object. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Usage"},{"location":"usage/#usage","text":"There are several methods to use business object defined with the @story decorator.","title":"Usage"},{"location":"usage/#call","text":"The most simple variant to execute story is to call it as a regular method.","title":"Call"},{"location":"usage/#result","text":"sync >>> from app.services import Subscription >>> Subscription () . buy ( category_id = 1 , price_id = 1 , profile_id = 1 ) Category(primary_key=1, name='Books', cost=7) async >>> import asyncio >>> from aioapp.services import Subscription >>> asyncio . run ( Subscription () . buy ( category_id = 1 , price_id = 1 , profile_id = 1 )) Category(primary_key=1, name='Books', cost=7) The story was executed successfully. It returns an object we put into Result marker.","title":"Result"},{"location":"usage/#failure","text":"sync >>> from app.services import Subscription >>> Subscription () . buy ( category_id = 2 , price_id = 2 , profile_id = 1 ) Traceback (most recent call last): ... _stories.exceptions.FailureError async >>> from aioapp.services import Subscription >>> asyncio . run ( Subscription () . buy ( category_id = 2 , price_id = 2 , profile_id = 1 )) Traceback (most recent call last): ... _stories.exceptions.FailureError Story failed. The user does not have enough money to complete this purchase. Failure marker throws an exception when call method was used.","title":"Failure"},{"location":"usage/#run","text":"A more powerful way to inspect the result of the story is to use the run method instead. The run method always returns an object. This object contains a summary of the business object execution.","title":"Run"},{"location":"usage/#result_1","text":"sync >>> from app.services import ShowCategory >>> result = ShowCategory () . show . run ( category_id = 1 , profile_id = 1 ) >>> result . is_success True >>> result . value Category(primary_key=1, name='Books', cost=7) async >>> import asyncio >>> from aioapp.services import ShowCategory >>> result = asyncio . run ( ShowCategory () . show . run ( category_id = 1 , profile_id = 1 )) >>> result . is_success True >>> result . value Category(primary_key=1, name='Books', cost=7) If the story was executed successfully, its actual result will be available in the value attribute.","title":"Result"},{"location":"usage/#failure_1","text":"sync >>> from app.services import ShowCategory >>> result = ShowCategory () . show . run ( category_id = 2 , profile_id = 1 ) >>> result . is_failure True >>> result . failed_on ( \"check_expiration\" ) True >>> result . failed_because ( ShowCategory () . show . failures . forbidden ) True >>> result . ctx ShowCategory.show find_subscription check_expiration (failed: <Errors.forbidden: 1>) <BLANKLINE> Context: category_id: 2 # Story argument profile_id: 1 # Story argument subscription: Subscription(primary_key=7) # Set by ShowCategory.find_subscription >>> result . ctx . subscription . is_expired () True >>> result . ctx . subscription . created datetime.date(2019, 1, 1) async >>> from aioapp.services import ShowCategory >>> result = asyncio . run ( ShowCategory () . show . run ( category_id = 2 , profile_id = 1 )) >>> result . is_failure True >>> result . failed_on ( \"check_expiration\" ) True >>> result . failed_because ( ShowCategory () . show . failures . forbidden ) True >>> result . ctx ShowCategory.show find_subscription check_expiration (failed: <Errors.forbidden: 1>) <BLANKLINE> Context: category_id: 2 # Story argument profile_id: 1 # Story argument subscription: Subscription(primary_key=7) # Set by ShowCategory.find_subscription >>> result . ctx . subscription . is_expired () True >>> result . ctx . subscription . created datetime.date(2019, 1, 1) run does not raise an error. Even if the story returns Failure marker. Instead, you can use methods like failed_on and failed_because to look for failed story method and exact reason. The argument used in the failed_because method will be described in more details in the failure protocol chapter. The context of the failed story is also available in the result object. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Failure"},{"location":"why/","text":"Why \u00b6 Good code is easy to understand and change. We build stories with this constrains in mind. stories force you to write structured, understandable code with right separation of concerns and responsibilities. Let's consider common troubles you meet in development. Micro framework \u00b6 Micro frameworks don't offer too much structure to your project. The main goal is flexibility. And you're mostly on your own when it comes to organizing your code. Most of the times you will end up with two problems: Long view functions. Lots of if statements inside this functions. There is a lot of complexity in it. Let's consider following view function. from flask import Flask app = Flask ( 'app' ) @app . route ( '/subscriptions/' ) # 85 def buy_subscription ( page ): # 86 # ... if props [ - 1 ] . endswith ( '$' ): # 121 props [ - 1 ] = props [ - 1 ][: - 1 ] # 122 <- # 123 We do not have any information about this strange comparison expression. Let's consider we should process this data in a different way to complete our current task. We decide to change this expression. Of course, we test all possible scenarios we can imagine. But after some time this error would happen in the production: Traceback (most recent call last): File \"views.py\" , line 1027 , in buy_subscription ZeroDivisionError : division by zero Turns out there were a lot more variants of incoming data than we can imagine. So our change failed in several business scenarios. This happens because our code wasn't written to help us understand it. Macro framework \u00b6 On the other side, there are a lot of technologies with strong opinions on how to structure programs written with their help. This approach also has its own cost. You need method flowchart to understand data flow in your system. Zig-zag traceback problem. It's hard to figure out the actual execution path because your code always mixed with the code of the framework. Framework internals leak into your code base. Let's consider this view: from rest_framework import viewsets from django_project.filters import SubscriptionFilter from django_project.models import Subscription from django_project.permissions import CanSubscribe from django_project.serializers import SubscriptionSerializer class SubscriptionViewSet ( viewsets . ModelViewSet ): queryset = Subscription . objects . all () serializer_class = SubscriptionSerializer permission_classes = ( CanSubscribe ,) filter_class = SubscriptionFilter The only thing we have clue about - it is somehow related to the subscription to our service. But it does not tell us: What exactly does this class do? How to use it? We need to keep framework documentation close to the sources to figure this out. After a few hours of digging, we will figure out there are about 17 different ways to interact with this view. When we go to the SubscriptionSerializer class, we expect to see there a mapping of fields from the database model to the JSON object. And we actually do. >>> from rest_framework.fields import IntegerField >>> from rest_framework.serializers import Serializer >>> class SubscriptionSerializer ( Serializer ): ... category_id = IntegerField () ... price_id = IntegerField () But in addition we see this method: >>> def recreate_nested_writable_fields ( self , instance ): ... for field , values in self . writable_fields_to_recreate (): ... related_manager = getattr ( instance , field ) ... related_manager . all () . delete () ... for data in values : ... obj = related_manager . model . objects . create ( ... to = instance , ** data ) ... related_manager . add ( obj ) Once again we have no idea... What was the actual reason to put this method there? Which one of the 17 ways to interact with the view does it affect? What framework state it expects to work with? It will take a few hours more to answer this questions. Conclusion \u00b6 In both projects built with micro and macro frameworks we end up with actually the same situation: Our code is fragile. We afraid to change it. It is hard to reason about. It is time-consuming to work with it. But there is a solution for it! Business logic \u00b6 The main problem with both approaches - it is completely unclear what the application actually does. What problems it is trying to solve? Most frameworks are busy with forms, serializers, transport layers, field mappings. And all these implementation details are not the right abstractions for decision making. Usually, our first thought will be moving our business logic from the view into a function. >>> def buy_subscription ( category_id , price_id , user ): ... ... category = find_category ( category_id ) ... price = find_price ( price_id ) ... profile = find_profile ( user ) ... if profile . balance < price . cost : ... raise ValueError ... decrease_balance ( profile , price . cost ) ... save_profile ( profile ) ... expires = calculate_period ( price . period ) ... subscription = create_subscription ( profile , category , expires ) ... notification = send_notification ( 'subscribe' , profile , category ) The author definitely has a few good points to write code this way. It is short, has clear names and intent. If you enjoy writing code like this, stop reading and go write it. I'm serious! But we see a few disadvantages in it. Growth problem. In real life, functions like this will have ~50 lines of code, a lot of variables and nested if statements. Eventually, a programmer will decide to hide its complexity somewhere. Convert to the object. The main intent is hiding ~50 variables in ~50 object attributes. This will improve the readability of the main method. But will harm the understanding of where data came from. Mixins. At some point, we will like to reuse parts of our business logic. A mixin is the most common way to make code with classes reusable. But it will lead to even more implicit source of data. Attributes appear from nowhere. Top-down architecture. We call functions directly. They call other low level functions directly. Our business logic has a very high coupling with the way we talk to the database, SMS gateway or notification server. This approach has zero flexibility. There is a better way. DSL \u00b6 Wouldn't it be nice if we can just read business logic as it was intended? >>> from stories import story , arguments >>> class Subscription : ... ... @story ... @arguments ( \"category_id\" , \"price_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification Wouldn't it be nice to have a clear understandable state? (Pdb) ctx Subscription.buy: find_category check_price check_purchase (PromoCode.validate) find_code (skipped) check_balance find_profile Context: category_id = 1318 # Story argument user = <User: 3292> # Story argument category = <Category: 1318> # Set by Subscription.find_category Wouldn't it be nice to know which business scenario was executed by every line in the tests? Wouldn't it be nice to see the same details in the debug toolbar? Wouldn't it be nice to have it when production fails? Interesting, isn't it? Check out Definition guide to learn more. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Why"},{"location":"why/#why","text":"Good code is easy to understand and change. We build stories with this constrains in mind. stories force you to write structured, understandable code with right separation of concerns and responsibilities. Let's consider common troubles you meet in development.","title":"Why"},{"location":"why/#micro-framework","text":"Micro frameworks don't offer too much structure to your project. The main goal is flexibility. And you're mostly on your own when it comes to organizing your code. Most of the times you will end up with two problems: Long view functions. Lots of if statements inside this functions. There is a lot of complexity in it. Let's consider following view function. from flask import Flask app = Flask ( 'app' ) @app . route ( '/subscriptions/' ) # 85 def buy_subscription ( page ): # 86 # ... if props [ - 1 ] . endswith ( '$' ): # 121 props [ - 1 ] = props [ - 1 ][: - 1 ] # 122 <- # 123 We do not have any information about this strange comparison expression. Let's consider we should process this data in a different way to complete our current task. We decide to change this expression. Of course, we test all possible scenarios we can imagine. But after some time this error would happen in the production: Traceback (most recent call last): File \"views.py\" , line 1027 , in buy_subscription ZeroDivisionError : division by zero Turns out there were a lot more variants of incoming data than we can imagine. So our change failed in several business scenarios. This happens because our code wasn't written to help us understand it.","title":"Micro framework"},{"location":"why/#macro-framework","text":"On the other side, there are a lot of technologies with strong opinions on how to structure programs written with their help. This approach also has its own cost. You need method flowchart to understand data flow in your system. Zig-zag traceback problem. It's hard to figure out the actual execution path because your code always mixed with the code of the framework. Framework internals leak into your code base. Let's consider this view: from rest_framework import viewsets from django_project.filters import SubscriptionFilter from django_project.models import Subscription from django_project.permissions import CanSubscribe from django_project.serializers import SubscriptionSerializer class SubscriptionViewSet ( viewsets . ModelViewSet ): queryset = Subscription . objects . all () serializer_class = SubscriptionSerializer permission_classes = ( CanSubscribe ,) filter_class = SubscriptionFilter The only thing we have clue about - it is somehow related to the subscription to our service. But it does not tell us: What exactly does this class do? How to use it? We need to keep framework documentation close to the sources to figure this out. After a few hours of digging, we will figure out there are about 17 different ways to interact with this view. When we go to the SubscriptionSerializer class, we expect to see there a mapping of fields from the database model to the JSON object. And we actually do. >>> from rest_framework.fields import IntegerField >>> from rest_framework.serializers import Serializer >>> class SubscriptionSerializer ( Serializer ): ... category_id = IntegerField () ... price_id = IntegerField () But in addition we see this method: >>> def recreate_nested_writable_fields ( self , instance ): ... for field , values in self . writable_fields_to_recreate (): ... related_manager = getattr ( instance , field ) ... related_manager . all () . delete () ... for data in values : ... obj = related_manager . model . objects . create ( ... to = instance , ** data ) ... related_manager . add ( obj ) Once again we have no idea... What was the actual reason to put this method there? Which one of the 17 ways to interact with the view does it affect? What framework state it expects to work with? It will take a few hours more to answer this questions.","title":"Macro framework"},{"location":"why/#conclusion","text":"In both projects built with micro and macro frameworks we end up with actually the same situation: Our code is fragile. We afraid to change it. It is hard to reason about. It is time-consuming to work with it. But there is a solution for it!","title":"Conclusion"},{"location":"why/#business-logic","text":"The main problem with both approaches - it is completely unclear what the application actually does. What problems it is trying to solve? Most frameworks are busy with forms, serializers, transport layers, field mappings. And all these implementation details are not the right abstractions for decision making. Usually, our first thought will be moving our business logic from the view into a function. >>> def buy_subscription ( category_id , price_id , user ): ... ... category = find_category ( category_id ) ... price = find_price ( price_id ) ... profile = find_profile ( user ) ... if profile . balance < price . cost : ... raise ValueError ... decrease_balance ( profile , price . cost ) ... save_profile ( profile ) ... expires = calculate_period ( price . period ) ... subscription = create_subscription ( profile , category , expires ) ... notification = send_notification ( 'subscribe' , profile , category ) The author definitely has a few good points to write code this way. It is short, has clear names and intent. If you enjoy writing code like this, stop reading and go write it. I'm serious! But we see a few disadvantages in it. Growth problem. In real life, functions like this will have ~50 lines of code, a lot of variables and nested if statements. Eventually, a programmer will decide to hide its complexity somewhere. Convert to the object. The main intent is hiding ~50 variables in ~50 object attributes. This will improve the readability of the main method. But will harm the understanding of where data came from. Mixins. At some point, we will like to reuse parts of our business logic. A mixin is the most common way to make code with classes reusable. But it will lead to even more implicit source of data. Attributes appear from nowhere. Top-down architecture. We call functions directly. They call other low level functions directly. Our business logic has a very high coupling with the way we talk to the database, SMS gateway or notification server. This approach has zero flexibility. There is a better way.","title":"Business logic"},{"location":"why/#dsl","text":"Wouldn't it be nice if we can just read business logic as it was intended? >>> from stories import story , arguments >>> class Subscription : ... ... @story ... @arguments ( \"category_id\" , \"price_id\" ) ... def buy ( I ): ... ... I . find_category ... I . find_price ... I . find_profile ... I . check_balance ... I . persist_payment ... I . persist_subscription ... I . send_subscription_notification Wouldn't it be nice to have a clear understandable state? (Pdb) ctx Subscription.buy: find_category check_price check_purchase (PromoCode.validate) find_code (skipped) check_balance find_profile Context: category_id = 1318 # Story argument user = <User: 3292> # Story argument category = <Category: 1318> # Set by Subscription.find_category Wouldn't it be nice to know which business scenario was executed by every line in the tests? Wouldn't it be nice to see the same details in the debug toolbar? Wouldn't it be nice to have it when production fails? Interesting, isn't it? Check out Definition guide to learn more. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"DSL"},{"location":"contrib/debug_toolbars/","text":"Debug Toolbars \u00b6 Many frameworks provide debug toolbar add-ons. stories integrate with these toolbars to show the execution path and context variables of all business objects triggered by the framework handler. Django contrib \u00b6 Add this lines to your developer's settings: >>> from debug_toolbar.settings import PANELS_DEFAULTS >>> INSTALLED_APPS = [ ... \"debug_toolbar\" , ... \"stories.contrib.debug_toolbars.django\" , ... ... , ... ] >>> MIDDLEWARE = [ ... \"debug_toolbar.middleware.DebugToolbarMiddleware\" , ... ... , ... ] >>> DEBUG_TOOLBAR_PANELS = PANELS_DEFAULTS + [ ... \"stories.contrib.debug_toolbars.django.StoriesPanel\" ... ] You should see stories panel in your debug toolbar: Flask contrib \u00b6 To show a stories panel in flask_debugtoolbar, add the panel to the DEBUG_TB_PANELS config variable before initializing DebugToolbarExtension : >>> from flask import Flask >>> from flask_debugtoolbar import DebugToolbarExtension >>> app = Flask ( __name__ ) >>> app . config [ 'DEBUG_TB_PANELS' ] = ( ... 'flask_debugtoolbar.panels.versions.VersionDebugPanel' , ... ... , ... 'stories.contrib.debug_toolbars.flask.StoriesPanel' ... ) >>> debug_toolbar = DebugToolbarExtension ( app ) \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Debug toolbars"},{"location":"contrib/debug_toolbars/#debug-toolbars","text":"Many frameworks provide debug toolbar add-ons. stories integrate with these toolbars to show the execution path and context variables of all business objects triggered by the framework handler.","title":"Debug Toolbars"},{"location":"contrib/debug_toolbars/#django-contrib","text":"Add this lines to your developer's settings: >>> from debug_toolbar.settings import PANELS_DEFAULTS >>> INSTALLED_APPS = [ ... \"debug_toolbar\" , ... \"stories.contrib.debug_toolbars.django\" , ... ... , ... ] >>> MIDDLEWARE = [ ... \"debug_toolbar.middleware.DebugToolbarMiddleware\" , ... ... , ... ] >>> DEBUG_TOOLBAR_PANELS = PANELS_DEFAULTS + [ ... \"stories.contrib.debug_toolbars.django.StoriesPanel\" ... ] You should see stories panel in your debug toolbar:","title":"Django contrib"},{"location":"contrib/debug_toolbars/#flask-contrib","text":"To show a stories panel in flask_debugtoolbar, add the panel to the DEBUG_TB_PANELS config variable before initializing DebugToolbarExtension : >>> from flask import Flask >>> from flask_debugtoolbar import DebugToolbarExtension >>> app = Flask ( __name__ ) >>> app . config [ 'DEBUG_TB_PANELS' ] = ( ... 'flask_debugtoolbar.panels.versions.VersionDebugPanel' , ... ... , ... 'stories.contrib.debug_toolbars.flask.StoriesPanel' ... ) >>> debug_toolbar = DebugToolbarExtension ( app ) \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Flask contrib"},{"location":"contrib/pytest/","text":"Py.Test contrib \u00b6 Py.test plugin provides an additional report for failed tests. It contains: Stories started by the failed test is chronological order. Exact execution path for each story. A context for each story. Corresponding source line of the test started each story. This plugin is enabled by default. To disable it add -p no:stories argument to the pytest command. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Py.test"},{"location":"contrib/pytest/#pytest-contrib","text":"Py.test plugin provides an additional report for failed tests. It contains: Stories started by the failed test is chronological order. Exact execution path for each story. A context for each story. Corresponding source line of the test started each story. This plugin is enabled by default. To disable it add -p no:stories argument to the pytest command. \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Py.Test contrib"},{"location":"contrib/sentry/","text":"Sentry contrib \u00b6 This is a picture of the execution path and context variables of the business object shown in the error report breadcrumbs section: Settings \u00b6 Import this module before import any Sentry related stuff: >>> import stories.contrib.sentry Django Settings \u00b6 If you use Django, you should add this section to your project config instead of the import statement documented above: >>> SENTRY_CLIENT = \"stories.contrib.sentry.django.DjangoClient\" \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Sentry"},{"location":"contrib/sentry/#sentry-contrib","text":"This is a picture of the execution path and context variables of the business object shown in the error report breadcrumbs section:","title":"Sentry contrib"},{"location":"contrib/sentry/#settings","text":"Import this module before import any Sentry related stuff: >>> import stories.contrib.sentry","title":"Settings"},{"location":"contrib/sentry/#django-settings","text":"If you use Django, you should add this section to your project config instead of the import statement documented above: >>> SENTRY_CLIENT = \"stories.contrib.sentry.django.DjangoClient\" \u2014 \u2b50\ufe0f \u2014 The stories library is part of the SOLID python family.","title":"Django Settings"}]}